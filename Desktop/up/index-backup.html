<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sound Factory">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>Sound Factory - Interactive Social Floor</title>
    <style>
        /* Common Styles */
        /* Removed: accidental global background override that tinted all UI */
        
        .header-link.tickets {
            background: linear-gradient(135deg, #ff1a78, #ff0066);
            border: 1px solid #ff1a78;
            box-shadow: 0 2px 8px rgba(255, 26, 120, 0.3);
        }
        
        .header-link.tickets:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 26, 120, 0.5);
        }
        
        .header-link.ai-tools {
            background: linear-gradient(135deg, #4ecdc4, #45b7d1);
            border: 1px solid #4ecdc4;
            box-shadow: 0 2px 8px rgba(78, 205, 196, 0.3);
        }
        
        .header-link.ai-tools:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.5);
        }
        
        /* Mobile Responsive Header */
        @media (max-width: 768px) {
            .site-header {
                padding: 10px;
                flex-wrap: wrap;
            }
            
            .logo {
                height: 30px;
            }
            
            .countdown-label {
                font-size: 8px;
            }
            
            .countdown-timer {
                font-size: 14px;
            }
            
            .header-link {
                padding: 6px 12px;
                font-size: 10px;
            }
        }
        
        @media (max-width: 480px) {
            .site-header {
                justify-content: center;
                gap: 10px;
            }
            
            .logo-container {
                flex-basis: 100%;
                justify-content: center;
                margin-bottom: 5px;
            }
            
            .header-nav {
                flex-basis: 100%;
                justify-content: space-between; /* Find Friends on left, Tables/Tickets on right */
            }
        }

        :root { --header-h: 56px; }

        /* Top mode switch (Find / Drop) */
        .mode-switch {
            display: inline-flex;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 999px;
            overflow: hidden;
            align-items: center;
        }
        .mode-tab {
            appearance: none;
            border: 0;
            background: transparent;
            color: rgba(255,255,255,0.9);
            font-weight: 700;
            font-size: 11px;
            letter-spacing: .5px;
            padding: 6px 10px;
            cursor: pointer;
            transition: background .15s ease, color .15s ease;
        }
        .mode-tab.active {
            background: #fff;
            color: #000;
        }
        @media (max-width: 480px) {
            .mode-tab { font-size: 10px; padding: 5px 8px; }
        }

        /* Prevent text selection on mobile */
        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        /* Re-enable selection for form controls and editable content */
        input, textarea, select, [contenteditable="true"] {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }

        /* Blueprint Styles - Floor Navigation */
        .nav-panel {
            width: 40px;
            background: rgba(26, 26, 26, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 8px 3px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: fixed;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
        }

        .floor-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .floor-btn {
            background: rgba(42, 42, 42, 0.9);
            border: 1.5px solid #3a3a3a;
            color: #bcbcbc;
            min-height: 35px;
            padding: 8px 2px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        .floor-btn:hover { color: #fff; border-color: #5a5a5a; }

        .floor-btn:active {
            transform: scale(0.92);
            transition: transform 0.1s ease;
        }

        .floor-btn.active {
            background: #fff;
            border-color: #fff;
            color: #000;
            box-shadow: 0 2px 10px rgba(255,255,255,0.25);
            animation: pulse 2s infinite;
        }

        .floor-btn.active:active {
            transform: scale(0.92);
        }

        @keyframes pulse {
            0% { box-shadow: 0 2px 10px rgba(255,255,255,0.20); }
            50% { box-shadow: 0 2px 14px rgba(255,255,255,0.35); }
            100% { box-shadow: 0 2px 10px rgba(255,255,255,0.20); }
        }

        .floor-indicator {
            position: absolute;
            left: 2px;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 15px;
            background: #fff;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .floor-btn.active .floor-indicator {
            opacity: 1;
        }


        /* Main content - truly full screen on mobile */
        .main-content {
            position: absolute;
            top: var(--header-h);
            left: 0;
            width: 100%;
            height: 100%;
            height: calc(100dvh - var(--header-h));
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .floor-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .floor {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0; /* flush to edges */
        }

        .floor.active {
            opacity: 1;
            visibility: visible;
        }

        /* Breathing flyer hint on empty spaces */
        .floor-hint {
            position: absolute;
            inset: 0;
            background: url('seance-flyer.jpg') center/contain no-repeat;
            opacity: 0.03;
            animation: breathe 8s ease-in-out infinite;
            pointer-events: none;
            z-index: 50; /* below pins (100) and flyers (120) */
        }
        @keyframes breathe {
            0% { transform: scale(1); opacity: 0.04; }
            50% { transform: scale(1.03); opacity: 0.08; }
            100% { transform: scale(1); opacity: 0.04; }
        }

        /* Pin shadow flyer reveal on hover (adapted from .map-pin) */
        .enhanced-pin::before {
            content: '';
            position: absolute;
            width: 120px;
            height: 68px;
            left: 50%;
            top: -85px;
            transform: translateX(-50%) rotate(45deg); /* counter parent -45deg */
            background: url('seance-flyer.jpg') center/cover no-repeat;
            opacity: 0;
            filter: blur(3px) brightness(1.05);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: 0 10px 22px rgba(0,0,0,0.45);
            pointer-events: none;
            transition: opacity 0.15s ease;
            z-index: 1;
        }
        .enhanced-pin:hover::before { opacity: 0.15; }

        /* Floor flash effect on change */
        .floor-flash::after {
            content: '';
            position: fixed; inset: 0; pointer-events: none; z-index: 3500;
            background: radial-gradient(120% 120% at 50% 50%, rgba(255,255,255,0.08), rgba(0,0,0,0) 60%);
            animation: floorFlash .4s ease-out forwards;
        }
        @keyframes floorFlash { from { opacity: 1; } to { opacity: 0; } }

        /* Flyer banner at the top of floors */
        .floor-flyer {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: min(440px, 82vw);
            border-radius: 14px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.08);
            background: rgba(10,10,10,0.65);
            backdrop-filter: blur(8px);
            box-shadow: 0 10px 30px rgba(0,0,0,.45);
            z-index: 120;
            display: none; /* becomes flex when enabled */
            align-items: center; gap: 6px; padding: 4px;
        }
        .floor.active .floor-flyer { display: flex; }
        .floor-flyer img { width: 100%; height: auto; display: block; border-radius: 10px; }
        .floor-flyer a { flex: 1; display: block; text-decoration: none; }
        .flyer-dismiss {
            position: absolute; top: 6px; right: 8px; width: 26px; height: 26px;
            border-radius: 50%; background: rgba(0,0,0,.45); color: #fff; font-size: 16px;
            border: 1px solid rgba(255,255,255,.15); cursor: pointer;
        }

        /* Full screen blueprint: no margins/letterbox, always fills below header */
        html, body { height: 100%; background: #000; margin: 0; }
        body { overflow: hidden; }
        .main-content { overflow: hidden; }
        .floor { overflow: hidden; }
        .floor > svg, svg.floor-svg {
            position: absolute;
            inset: 0;
            width: 100% !important;
            height: 100% !important;
            max-width: none !important;
            max-height: none !important;
            display: block;
            filter: drop-shadow(0 0 15px rgba(0,0,0,0.6));
        }

        /* Tablet styles (768px and up) */
        @media (min-width: 768px) {
            .nav-panel {
                width: 50px;
                right: 15px;
                padding: 10px 4px;
                gap: 6px;
                border-radius: 15px;
            }

            .floor-buttons {
                gap: 6px;
            }

            .floor-btn {
                min-height: 38px;
                padding: 10px 3px;
                font-size: 12px;
                border-radius: 10px;
            }

            .floor-btn:hover {
                background: #353535;
                border-color: #555;
                color: #aaa;
                transform: scale(1.05);
            }

            .floor-btn:active {
                transform: scale(1);
            }

            .floor-indicator {
                width: 4px;
                height: 18px;
                left: 3px;
            }

            /* Ensure blueprint still fills container on tablet */
            .floor > svg, svg.floor-svg { padding: 0; }
        }

        /* Desktop styles (1024px and up) */
        @media (min-width: 1024px) {
            .nav-panel {
                width: 50px;
                right: 25px;
                padding: 8px 4px;
                gap: 4px;
                border-radius: 12px;
            }

            .floor-buttons {
                gap: 4px;
            }

            .floor-btn {
                min-height: 36px;
                padding: 8px 2px;
                font-size: 11px;
                border-radius: 8px;
                border-width: 2px;
            }

            .floor-indicator {
                width: 4px;
                height: 16px;
                left: 3px;
            }

            /* no additional desktop constraints */
        }

        /* Landscape mobile optimization - even smaller */
        @media (max-height: 500px) and (orientation: landscape) {
            .nav-panel {
                width: 36px;
                top: 50%;
                right: 6px;
                padding: 5px 2px;
                gap: 3px;
            }

            .floor-btn {
                min-height: 30px;
                padding: 6px 1px;
                font-size: 10px;
            }

            svg {
                max-width: calc(100vw - 50px);
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            .nav-panel {
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            }
        }

        /* Character Styles from jpins.html */
        .character {
            position: fixed;
            width: 24px;
            height: 24px;
            pointer-events: auto;
            z-index: 100;
            transform: translate(-12px, -12px);
            cursor: pointer;
        }

        /* Head (tiny) */
        .head {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 255, 255, 0.9), 
                var(--color));
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px var(--color);
            z-index: 10;
        }

        /* Limbs (tiny) */
        .arm, .leg {
            position: absolute;
            width: 2px;
            background: var(--color);
            opacity: 0.8;
            transform-origin: center;
        }

        .arm {
            height: 6px;
            top: 50%;
        }

        .arm.left {
            left: 6px;
            transform: translateY(-50%) rotate(-20deg);
        }

        .arm.right {
            right: 6px;
            transform: translateY(-50%) rotate(20deg);
        }

        .leg {
            height: 8px;
            top: 50%;
        }

        .leg.left {
            left: 8px;
            transform: translateY(-50%) rotate(-10deg);
        }

        .leg.right {
            right: 8px;
            transform: translateY(-50%) rotate(10deg);
        }

        /* Normal Walk */
        /* Disabled walking animations */
        .character.walking .leg.left { animation: none; }
        .character.walking .leg.right { animation: none; }

        @keyframes walkLegLeft {
            0%, 100% { transform: translateY(-50%) rotate(-10deg); }
            50% { transform: translateY(-50%) rotate(10deg); }
        }

        @keyframes walkLegRight {
            0%, 100% { transform: translateY(-50%) rotate(10deg); }
            50% { transform: translateY(-50%) rotate(-10deg); }
        }

        /* Runway Walk - Flamboyant */
        /* Disabled runway animations */
        .character.runway .leg { animation: none !important; }
        .character.runway .arm { animation: none !important; }
        .character.runway .head { animation: none !important; }

        @keyframes runwayLeg {
            0%, 100% { 
                transform: translateY(-50%) rotate(-30deg) translateX(-2px);
            }
            25% {
                transform: translateY(-50%) rotate(0deg) translateX(0) scaleY(1.2);
            }
            50% { 
                transform: translateY(-50%) rotate(30deg) translateX(2px);
            }
            75% {
                transform: translateY(-50%) rotate(0deg) translateX(0) scaleY(1.2);
            }
        }

        @keyframes runwayArm {
            0%, 100% { 
                transform: translateY(-50%) rotate(-45deg);
            }
            50% { 
                transform: translateY(-50%) rotate(45deg);
            }
        }

        @keyframes runwayHead {
            0%, 100% { 
                transform: translate(-50%, -50%) rotate(-10deg) scale(1);
            }
            50% { 
                transform: translate(-50%, -50%) rotate(10deg) scale(1.1);
            }
        }

        /* Breakdance Walk - Tough */
        /* Disabled breakdance animations */
        .character.breakdance .leg { animation: none !important; }
        .character.breakdance .arm { animation: none !important; }
        .character.breakdance { animation: none; }

        /* Safety: disable any residual animations on character subtree */
        .character, .character * { animation: none !important; transition: none !important; }

        @keyframes bboyStomp {
            0%, 100% { 
                transform: translateY(-50%) rotate(-15deg) scaleY(0.9);
            }
            50% { 
                transform: translateY(-50%) rotate(15deg) scaleY(1.1);
            }
        }

        @keyframes bboyArm {
            0%, 100% { 
                transform: translateY(-50%) rotate(-35deg) scaleX(1.2);
            }
            50% { 
                transform: translateY(-50%) rotate(35deg) scaleX(1.2);
            }
        }

        @keyframes bboyBounce {
            0%, 100% { transform: translate(-15px, -15px) scale(1); }
            50% { transform: translate(-15px, -17px) scale(1.05); }
        }

        /* Proximity Chat Bubble */
        .chat-bubble {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 10px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 200;
        }

        .chat-bubble.show {
            opacity: 1;
        }

        /* Social Menu (on hover) */
        .social-menu {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 8px;
            display: none;
            gap: 5px;
            z-index: 300;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Disable hover social menu popups; actions live in the profile card */
        .character:hover .social-menu { display: none; }
        .social-menu { display: none !important; }

        .social-btn {
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .social-btn:hover {
            background: var(--hover-color);
            transform: scale(1.2);
        }

        /* Proximity Ring */
        .proximity-ring {
            position: absolute;
            width: 0px; /* disabled to save space */
            height: 0px; /* disabled to save space */
            border: none;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0; /* keep off */
            transition: none;
        }

        .character.near-others .proximity-ring { opacity: 0; animation: none; }

        @keyframes proximityPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        /* Group chat UI removed */
        .participant-avatar {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: grid;
            place-items: center;
            font-size: 9px;
            font-weight: 700;
            color: #000;
            background: #fff;
        }

        
        /* Pin Drop Animation */
        @keyframes pinDrop {
            0% {
                transform: translate(-50%, -200%) scale(0);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -100%) scale(1);
                opacity: 1;
            }
        }

        /* Show joystick by default; hide only if user chose to */
        .sf-joystick { display: block; }
        /* Debug: force show joystick on desktop when body has joy-debug */
        body.joy-debug .sf-joystick { display: block !important; }
        body.joy-debug .sf-joystick-toggle { display: flex !important; }
        .profile-sub {
            font-size: 9px;
            color: #9aa3b2;
        }
        .profile-actions {
            display: flex;
            gap: 6px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        /* Removed: old CSS grid background (replaced by per-floor SVG blueprints) */
        .profile-card .offline { color: rgba(255,255,255,0.6); }
        .character.offline { filter: grayscale(1) brightness(0.8); opacity: 0.7; }
        .profile-btn {
            flex: 1 1 48%;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.08);
            color: #fff;
            font-size: 10px;
            font-weight: 700;
                border: 1px solid var(--color, #ffffff);
            /* Unified toast notifications (stack, small avatars) */
            #toastStack { position: fixed; top: 70px; right: 10px; z-index: 5000; display: flex; flex-direction: column; gap: 8px; }
            .notification-toast { display: grid; grid-template-columns: 28px 1fr; gap: 8px; align-items: center;
                padding: 8px 10px; background: rgba(0,0,0,0.9); color: #fff; border: 1px solid rgba(255,255,255,0.12);
                border-radius: 10px; box-shadow: 0 8px 24px rgba(0,0,0,.35); min-width: 220px; animation: notificationPop 0.25s ease; }
            .notification-toast img { width: 28px; height: 28px; border-radius: 6px; object-fit: cover; border: 1px solid rgba(255,255,255,0.15); }
            .notification-toast strong { font-size: 12px; }
            .notification-toast p { font-size: 11px; opacity: 0.8; margin: 0; }
            padding: 5px 6px;
            cursor: pointer;
        }
        .profile-btn:active { transform: scale(0.98); }

        /* Mobile tiny scaling */
        @media (max-width: 480px) {
            .profile-card {
                min-width: 150px;
                max-width: 180px;
                padding: 6px;
                border-radius: 10px;
            }
            .profile-avatar { width: 24px; height: 24px; border-radius: 7px; }
            .profile-name { font-size: 10px; }
            .profile-sub { font-size: 8.5px; }
            .profile-btn { font-size: 9px; padding: 4px 5px; }
        }
            /* Ensure profile card can host pseudo elements */
            .profile-card { position: relative; overflow: hidden; }

        /* Controls */
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 8px;
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 200;
        }

        .mode-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: none;
            border-radius: 15px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .mode-btn.active {
            background: #ffffff;
            color: #000000;
        }

        /* Status */
        .status {
            position: fixed;
            bottom: 90px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 10px 15px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 11px;
            z-index: 200;
        }

        .people-count {
            color: #ffffff;
            font-weight: bold;
        }

        

        /* Notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            animation: notificationPop 2s ease-out forwards;
            border: 1px solid var(--color, #ffffff);
        }

        @keyframes notificationPop {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }
            40% {
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
        }

        /* AI Vocal Studio Integration */
        .vocal-studio-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .vocal-studio-overlay.active {
            display: flex;
        }

        .studio-container {
            width: 95%;
            max-width: 1200px;
            height: 90%;
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: grid;
            grid-template-rows: auto 1fr auto;
            overflow: hidden;
        }

        /* Vocal Studio Header */
        .vocal-header-bar {
            background: #2a2a2a;
            border-bottom: 1px solid #000;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .vocal-logo-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .vocal-sf-logo {
            height: 30px;
            filter: invert(1);
            opacity: 0.9;
        }

        .vocal-title {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 2px;
            color: #ff0066;
        }

        .vocal-close-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 20px;
            transition: all 0.3s ease;
        }

        .vocal-close-btn:hover {
            background: rgba(255, 0, 102, 0.2);
            border-color: #ff0066;
        }

        .vocal-status-indicators {
            display: flex;
            gap: 20px;
        }

        .vocal-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 10px;
            color: #666;
        }

        .vocal-indicator-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
        }

        .vocal-indicator-dot.active {
            background: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }

        /* Vocal Studio Main Content */
        .vocal-main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 1px;
            background: #333;
            height: 100%;
        }

        /* Recording Panel */
        .vocal-recording-panel {
            background: #0f0f0f;
            display: flex;
            flex-direction: column;
        }

        /* Transport Controls */
        .vocal-transport {
            background: #1a1a1a;
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .vocal-record-btn {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #3a0000, #1a0000);
            border: 3px solid #660000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .vocal-record-btn:hover {
            border-color: #880000;
        }

        .vocal-record-btn.armed {
            background: radial-gradient(circle, #660000, #330000);
            border-color: #ff0000;
        }

        .vocal-record-btn.recording {
            background: radial-gradient(circle, #ff0000, #cc0000);
            border-color: #ff3333;
            animation: vocalRecordPulse 1s infinite;
        }

        @keyframes vocalRecordPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        .vocal-record-dot {
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            opacity: 0.8;
        }

        .vocal-record-btn.recording .vocal-record-dot {
            border-radius: 4px;
            width: 20px;
            height: 20px;
        }

        .vocal-time-displays {
            display: flex;
            gap: 20px;
        }

        .vocal-time-display {
            background: #000;
            padding: 10px 20px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .vocal-time-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .vocal-time-value {
            font-family: 'SF Mono', monospace;
            font-size: 20px;
            color: #00ff00;
            letter-spacing: 2px;
        }

        /* Waveform Display */
        .vocal-waveform-section {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .vocal-waveform-container {
            flex: 1;
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        #vocalWaveformCanvas {
            width: 100%;
            height: 100%;
        }

        .vocal-waveform-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        /* VU Meters */
        .vocal-meters-container {
            display: flex;
            gap: 10px;
        }

        .vocal-meter-group {
            flex: 1;
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .vocal-meter-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .vocal-meter-bar {
            height: 6px;
            background: #000;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .vocal-meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, 
                #00ff00 0%, 
                #00ff00 60%, 
                #ffff00 80%, 
                #ff6600 90%, 
                #ff0000 100%);
            transition: width 0.05s ease-out;
        }

        /* AI Processing Panel */
        .vocal-ai-panel {
            background: #151515;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .vocal-ai-header {
            background: #1a1a1a;
            padding: 15px 20px;
            border-bottom: 1px solid #333;
        }

        .vocal-ai-title {
            font-size: 12px;
            font-weight: 700;
            color: #0099ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .vocal-ai-status {
            font-size: 10px;
            color: #666;
        }

        .vocal-ai-status.processing {
            color: #ffff00;
        }

        .vocal-ai-status.ready {
            color: #00ff00;
        }

        /* AI Controls */
        .vocal-ai-controls {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .vocal-control-section {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 15px;
        }

        .vocal-control-title {
            font-size: 10px;
            text-transform: uppercase;
            color: #666;
            margin-bottom: 15px;
            letter-spacing: 1px;
        }

        /* Switches */
        .vocal-switch-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .vocal-switch-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .vocal-switch-label {
            font-size: 11px;
            color: #999;
        }

        .vocal-switch {
            width: 40px;
            height: 22px;
            background: #333;
            border-radius: 11px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .vocal-switch.active {
            background: #0099ff;
        }

        .vocal-switch-handle {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background: #666;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .vocal-switch.active .vocal-switch-handle {
            left: 20px;
            background: #fff;
        }

        /* Key Detection Display */
        .vocal-key-display {
            background: #000;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
            margin-top: 10px;
        }

        .vocal-key-label {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .vocal-key-value {
            font-size: 24px;
            font-weight: 700;
            color: #ff0066;
            letter-spacing: 2px;
        }

        .vocal-bpm-value {
            font-size: 18px;
            color: #0099ff;
            margin-top: 5px;
        }

        /* Vocal Studio Button */
        .vocal-studio-btn {
            position: fixed;
            bottom: 80px;
            right: 80px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #ff0066, #ff3399);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1600;
            box-shadow: 0 4px 15px rgba(255, 0, 102, 0.4);
        }

        .vocal-studio-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(255, 0, 102, 0.6);
        }

        /* ALAMS - AI Live Audio Manipulation System */
        .alams-btn {
            position: fixed;
            bottom: 80px;
            right: 150px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .alams-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        /* Live Stream Share Button */
        .live-share-btn {
            position: fixed;
            bottom: 80px;
            right: 80px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #ff0000, #ff6b6b);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1600;
            box-shadow: 0 4px 15px rgba(255, 0, 0, 0.4);
            animation: pulse 2s infinite;
        }

        .live-share-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(255, 0, 0, 0.6);
        }

        /* Bigger AI Buttons - Bottom Right (Higher to avoid overlap) */
        .ai-studio-btn {
            position: fixed;
            bottom: 120px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 3px solid #667eea;
            border-radius: 12px;
            color: #667eea;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1600;
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-studio-btn:hover {
            transform: translateY(-3px) scale(1.08);
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.5);
            border-color: #764ba2;
        }

        .ai-sampler-btn {
            position: fixed;
            bottom: 120px;
            right: 90px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 3px solid #ff6b35;
            border-radius: 12px;
            color: #ff6b35;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1600;
            box-shadow: 0 6px 16px rgba(255, 107, 53, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-sampler-btn:hover {
            transform: translateY(-3px) scale(1.08);
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: white;
            box-shadow: 0 10px 25px rgba(255, 107, 53, 0.5);
            border-color: #f7931e;
        }

        @keyframes pulse {
            0% { box-shadow: 0 4px 15px rgba(255, 0, 0, 0.4); }
            50% { box-shadow: 0 4px 25px rgba(255, 0, 0, 0.8); }
            100% { box-shadow: 0 4px 15px rgba(255, 0, 0, 0.4); }
        }



        /* Sound Factory Integrated Chat System */
        #sf-chat-system {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 2px solid rgba(255, 107, 53, 0.3);
            z-index: 1500;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            display: flex;
            flex-direction: column;
        }

        #sf-chat-system.expanded {
            height: 200px;
            background: rgba(0, 0, 0, 0.98);
            border-top-color: #ff6b35;
            box-shadow: 0 -10px 40px rgba(255, 107, 53, 0.3);
        }

        .sf-chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px;
            border-bottom: 1px solid rgba(255, 107, 53, 0.2);
            height: 40px;
        }

        .sf-chat-title {
            color: #ff6b35;
            font-weight: 700;
            font-size: 14px;
            letter-spacing: 1px;
        }

        .sf-chat-toggle {
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
        }

        .sf-chat-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
        }

        .sf-chat-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #sf-chat-system.expanded .sf-chat-content {
            opacity: 1;
        }

        .sf-chat-messages {
            flex: 1;
            padding: 15px 20px;
            overflow-y: auto;
            max-height: 200px;
        }

        .sf-chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(255, 107, 53, 0.1);
            border-radius: 8px;
            border-left: 3px solid #ff6b35;
        }

        .sf-chat-message.system {
            background: rgba(255, 255, 255, 0.05);
            border-left-color: #666;
        }

        .sf-message-time {
            font-size: 11px;
            color: #888;
            font-weight: 600;
        }

        .sf-chat-input-area {
            display: flex;
            padding: 10px 20px;
            gap: 10px;
            border-top: 1px solid rgba(255, 107, 53, 0.2);
        }

        #sfChatInput {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            font-size: 13px;
        }

        #sfChatInput:focus {
            outline: none;
            border-color: #ff6b35;
            box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.2);
        }

        .sf-send-btn {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sf-send-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
        }

        /* Identity Selection Modal */
        .identity-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.98);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .identity-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .identity-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #ff6b35;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .identity-modal.active .identity-content {
            transform: scale(1);
        }

        .identity-title {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #ff6b35, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .identity-subtitle {
            color: #aaa;
            margin-bottom: 30px;
            font-size: 16px;
        }

        .identity-options {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }

        .identity-option {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid rgba(255, 107, 53, 0.3);
            border-radius: 12px;
            padding: 15px 10px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .identity-option:hover {
            transform: translateY(-3px) scale(1.05);
            border-color: #ff6b35;
            box-shadow: 0 8px 20px rgba(255, 107, 53, 0.3);
        }

        .identity-option.selected {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            border-color: #f7931e;
            color: #000;
            box-shadow: 0 6px 16px rgba(255, 107, 53, 0.5);
        }

        .identity-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .identity-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .identity-custom {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #customIdentity {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            color: #fff;
            font-size: 14px;
        }

        #customIdentity:focus {
            outline: none;
            border-color: #ff6b35;
            box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.2);
        }

        .custom-submit-btn {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .custom-submit-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
        }


        /* ALAMS Overlay */
        .alams-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 3500;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .alams-overlay.active {
            display: flex;
        }

        .alams-container {
            width: 95%;
            max-width: 1400px;
            height: 90%;
            background: linear-gradient(145deg, #1e1e1e, #2a2a2a);
            border-radius: 12px;
            border: 3px solid #333;
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            grid-template-rows: 120px 200px 150px 100px;
            gap: 20px;
            padding: 20px;
            position: relative;
        }

        /* ALAMS Header */
        .alams-header {
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 10px 30px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 18px;
            letter-spacing: 2px;
        }

        .alams-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 20px;
            transition: all 0.3s ease;
        }

        .alams-close-btn:hover {
            background: rgba(255, 0, 102, 0.2);
            border-color: #ff0066;
        }

        /* Capture Section */
        .alams-capture-section {
            grid-column: 1;
            grid-row: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, #ff6b6b, #ee5a52);
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #ff5555;
            position: relative;
        }

        .alams-capture-section:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        .alams-capture-section.recording {
            animation: alamsCaptureRecord 1s infinite;
        }

        @keyframes alamsCaptureRecord {
            0% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(255, 107, 107, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0); }
        }

        .alams-capture-timer {
            position: absolute;
            bottom: 10px;
            font-size: 14px;
            font-family: 'SF Mono', monospace;
        }

        /* Status Panel */
        .alams-status-panel {
            grid-column: 3;
            grid-row: 1;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #333;
        }

        .alams-status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .alams-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
        }

        .alams-status-dot.active {
            background: #00ff88;
            box-shadow: 0 0 8px #00ff88;
        }

        /* Controls Container */
        .alams-controls-container {
            grid-column: 1 / 4;
            grid-row: 2;
            display: flex;
            justify-content: space-around;
            align-items: center;
            background: linear-gradient(145deg, #2d2d2d, #1d1d1d);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #444;
        }

        /* Knobs */
        .alams-knob {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(145deg, #3a3a3a, #1a1a1a);
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid #555;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .alams-knob:hover {
            transform: scale(1.1);
            border-color: #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }

        .alams-knob-label {
            position: absolute;
            bottom: -30px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            color: #ccc;
            width: 120px;
        }

        .alams-knob-indicator {
            width: 4px;
            height: 40px;
            background: linear-gradient(to bottom, #00ff88, #00cc66);
            position: absolute;
            top: 10px;
            border-radius: 2px;
            transform-origin: center 50px;
            transition: transform 0.2s ease;
        }

        .alams-led-ring {
            position: absolute;
            width: 140px;
            height: 140px;
            border: 3px solid transparent;
            border-radius: 50%;
            top: -13px;
            left: -13px;
            background: conic-gradient(from 0deg, #00ff88 0%, #00ff88 25%, transparent 25%);
            opacity: 0.7;
        }

        /* Waveform Display */
        .alams-waveform-display {
            grid-column: 1 / 4;
            grid-row: 3;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            border: 2px solid #333;
        }

        .alams-waveform {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(102, 126, 234, 0.3) 25%,
                rgba(118, 75, 162, 0.5) 50%,
                rgba(255, 107, 107, 0.3) 75%,
                transparent 100%);
            position: relative;
        }

        .alams-playhead {
            position: absolute;
            top: 0;
            left: 30%;
            width: 2px;
            height: 100%;
            background: #00ff88;
            animation: alamsPulse 1s infinite;
        }

        @keyframes alamsPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Export Controls */
        .alams-export-controls {
            grid-column: 1;
            grid-row: 4;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #333;
        }

        .alams-export-btn {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        .alams-export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }

        .alams-export-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Metronome Display */
        .alams-metronome-display {
            grid-column: 2;
            grid-row: 4;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-radius: 10px;
            border: 2px solid #333;
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
        }

        /* Recording Timer */
        .alams-recording-timer {
            grid-column: 3;
            grid-row: 4;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-radius: 10px;
            border: 2px solid #333;
        }

        .alams-timer-display {
            font-size: 20px;
            font-family: 'SF Mono', monospace;
            color: #ff6b6b;
            margin-bottom: 5px;
        }

        .alams-timer-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        /* Mobile Responsive for ALAMS */
        @media (max-width: 768px) {
            .alams-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto auto;
                height: 95%;
                gap: 15px;
            }
            
            .alams-capture-section {
                grid-column: 1;
                grid-row: 1;
            }
            
            .alams-status-panel {
                grid-column: 1;
                grid-row: 2;
            }
            
            .alams-controls-container {
                grid-column: 1;
                grid-row: 3;
                flex-wrap: wrap;
                gap: 15px;
            }
            
            .alams-knob {
                width: 80px;
                height: 80px;
            }
            
            .alams-waveform-display {
                grid-column: 1;
                grid-row: 4;
                height: 100px;
            }
            
            .alams-export-controls,
            .alams-metronome-display,
            .alams-recording-timer {
                grid-column: 1;
                grid-row: 5;
                display: flex;
                flex-direction: row;
                justify-content: space-around;
            }
            
            .alams-btn {
                bottom: 140px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        /* Mobile Responsive for Vocal Studio */
        @media (max-width: 768px) {
            .vocal-main-content {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto;
            }
            
            .vocal-ai-panel {
                max-height: 300px;
            }
            
            .vocal-studio-btn {
                bottom: 140px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        /* Navigation Links - Top Right */
        .nav-links {
            position: fixed;
            top: 10px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 15px;
        }

        .nav-link {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            text-decoration: none;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: rgba(255, 26, 120, 0.8);
            border-color: #ff1a78;
        }

        .nav-link.highlight {
            background: linear-gradient(135deg, #ff1a78, #ff0066);
            border: 1px solid #ff1a78;
            box-shadow: 0 2px 8px rgba(255, 26, 120, 0.3);
        }

        .nav-link.highlight:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 26, 120, 0.5);
        }

        /* Enhanced Pin System Animations */
        @keyframes dropIn {
            from { transform: rotate(-45deg) translate(-50%, -150%) scale(0); opacity: 0; }
            to { transform: rotate(-45deg) translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        
        @keyframes sparkle {
            to { transform: translateY(-20px) rotate(180deg); opacity: 0; }
        }
        
        /* Disco Ball - No Animation */
        #discoBall {
            cursor: move;
        }
        
        @keyframes discoSpin {
            from { transform: translate(200, 150) rotate(0deg); }
            to { transform: translate(200, 150) rotate(360deg); }
        }
        
        @keyframes discoTilesSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes floatUp {
            to { transform: translateY(-40px); opacity: 0; }
        }
        
        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* Blinking & Animated Pin Styles */
        .enhanced-pin {
            width: 10px !important;
            height: 10px !important;
            border-radius: 50% 50% 50% 0;
            position: absolute;
            cursor: pointer;
            transition: all 0.3s ease;
            transform: rotate(-45deg);
        }

        /* Engagement Blinkers */
        .enhanced-pin.high-activity {
            background: #ff0066;
            animation: redPulse 1s ease-in-out infinite;
            box-shadow: 0 0 8px rgba(255, 0, 102, 0.6);
        }

        @keyframes redPulse {
            0%, 100% { 
                transform: rotate(-45deg) scale(1);
                box-shadow: 0 0 8px rgba(255, 0, 102, 0.6);
            }
            50% { 
                transform: rotate(-45deg) scale(1.2);
                box-shadow: 0 0 15px rgba(255, 0, 102, 0.9);
            }
        }

        .enhanced-pin.new-drop {
            background: #ffcc00;
            animation: yellowFlicker 0.8s ease-in-out infinite;
        }

        @keyframes yellowFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .enhanced-pin.throwback {
            background: #0066ff;
            animation: blueGlow 2s ease-in-out infinite;
        }

        @keyframes blueGlow {
            0%, 100% { 
                box-shadow: 0 0 5px rgba(0, 102, 255, 0.4);
            }
            50% { 
                box-shadow: 0 0 12px rgba(0, 102, 255, 0.8);
            }
        }

        /* Ticket & Promo Blinkers */
        .enhanced-pin.promo {
            background: #9933ff;
            animation: purpleSparkle 1.5s ease-in-out infinite;
        }

        @keyframes purpleSparkle {
            0%, 100% { 
                transform: rotate(-45deg) scale(1);
                box-shadow: 0 0 6px rgba(153, 51, 255, 0.6);
            }
            25% { 
                transform: rotate(-45deg) scale(1.1);
                box-shadow: 0 0 12px rgba(153, 51, 255, 0.9);
            }
            50% { 
                transform: rotate(-45deg) scale(1);
                box-shadow: 0 0 8px rgba(153, 51, 255, 0.7);
            }
            75% { 
                transform: rotate(-45deg) scale(1.1);
                box-shadow: 0 0 12px rgba(153, 51, 255, 0.9);
            }
        }

        .enhanced-pin.group-deal {
            background: #00ff88;
            animation: greenBlink 1s ease-in-out infinite;
        }

        @keyframes greenBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .enhanced-pin.rare-gold {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            animation: goldFlash 0.6s ease-in-out infinite;
        }

        @keyframes goldFlash {
            0%, 100% { 
                transform: rotate(-45deg) scale(1);
                box-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
            }
            50% { 
                transform: rotate(-45deg) scale(1.3);
                box-shadow: 0 0 20px rgba(255, 215, 0, 1);
            }
        }

        /* Pin Hover Effects */
        /* Removed duplicate .enhanced-pin::before override (consolidated above) */
        .pin-cluster {
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .pin-cluster:hover {
            transform: scale(1.3);
            background: rgba(255, 255, 255, 1);
        }

        /* Pin Interaction Menu */
        .pin-interaction-menu {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%) scale(0);
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 8px;
            display: flex;
            gap: 5px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 200;
        }

        .pin-interaction-menu.visible {
            transform: translateX(-50%) scale(1);
        }

        .pin-action-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pin-action-btn:hover {
            transform: scale(1.2);
        }

        .pin-action-btn.drink {
            background: linear-gradient(135deg, #ff9900, #ff6600);
        }

        .pin-action-btn.wink {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
        }

        .pin-action-btn.beat {
            background: linear-gradient(135deg, #00ffff, #0099ff);
        }

        .pin-action-btn.highfive {
            background: linear-gradient(135deg, #00ff88, #00cc66);
        }
        /* Dimmed/idle pin visual */
        .enhanced-pin.dimmed { filter: grayscale(1) brightness(0.7); opacity: 0.65; box-shadow: 0 0 0 transparent !important; }
        .enhanced-pin.live { filter: none; opacity: 1; }
        
    /* Chat persona styles removed */
        /* Onboarding modal */
        .onboard-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.75); backdrop-filter: blur(6px); display: none; align-items: center; justify-content: center; z-index: 6000; }
        .onboard-card { width: min(92vw, 420px); background: rgba(20,22,26,0.96); border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 16px; color: #eef; box-shadow: 0 12px 40px rgba(0,0,0,0.45); }
        .onboard-head { display:flex; gap:10px; align-items:center; margin-bottom:8px; }
        .onboard-logo { width: 36px; height: 36px; border-radius: 8px; background:#111 url('sf-logo.png') center/contain no-repeat; border:1px solid rgba(255,255,255,0.15); }
        .onboard-title { font-weight: 800; letter-spacing: .5px; }
        .onboard-copy { font-size: 13px; color: #aab4c3; line-height: 1.4; margin-bottom: 10px; }
        .onboard-actions { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
        .on-btn { background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.16); color:#fff; padding:10px; border-radius: 10px; font-weight:700; font-size:12px; cursor:pointer; }
        .on-btn.primary { background: linear-gradient(135deg, #ff1a78, #ff0066); border-color: rgba(255,26,120,0.6); }
        .onboard-foot { display:flex; justify-content: space-between; align-items:center; margin-top:10px; }
        .on-skip { background: transparent; border: none; color:#aab4c3; font-size:12px; text-decoration: underline; cursor:pointer; }
        .on-note { font-size: 11px; color:#7e8a99; }
    </style>
    <style>
        /* Header polish overrides */
        .site-header {
            position: fixed; inset: 0 0 auto 0; height: var(--header-h);
            padding: 6px 14px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 2px 18px rgba(0,0,0,0.35);
            z-index: 2000;
        }
        .header-inner { max-width: 1200px; margin: 0 auto; display: flex; align-items: center; justify-content: space-between; gap: 10px; }
        .logo-container { display: flex; align-items: center; gap: 10px; }
        /* Text wordmark to replace image logo */
        .brand-wordmark { display:flex; align-items:center; gap:6px; font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, sans-serif; font-weight: 800; letter-spacing: .6px; }
        .brand-strong { font-size: 16px; color:#fff; }
        .brand-thin { font-size: 14px; color: rgba(255,255,255,0.65); font-weight:700; }
        /* Subtle accent bar to the left for polish */
    /* Remove accent bar to keep header truly monochrome */
    .brand-wordmark::before { content:""; display:none; }
        .countdown-container { align-items: flex-start; }
        .countdown-label { color: rgba(255,255,255,0.6); }
    .countdown-timer { font-size: 12px; font-weight: 800; color: #fff; letter-spacing: .5px; padding: 1px 8px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); }
        .header-nav { display: flex; gap: 8px; align-items: center; flex: 1; }
        .header-nav .mode-switch { margin-right: auto; }
        .header-link { padding: 8px 12px; border-radius: 10px; font-size: 13px; font-weight: 800; letter-spacing: .5px; text-decoration: none; transition: all .25s ease; color: #fff; }
    .header-link.tables, .header-link.tickets { 
        background: rgba(255,255,255,0.08); 
        border: 1px solid rgba(255,255,255,0.18); 
        color:#fff; 
        padding: 12px 18px; 
        font-size: 16px; 
        font-weight: 900; 
        letter-spacing: 1px;
        border-radius: 15px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .header-link.tables:hover, .header-link.tickets:hover { 
        background: rgba(255,255,255,0.2); 
        border-color: rgba(255,255,255,0.3); 
        transform: scale(1.05);
        box-shadow: 0 6px 16px rgba(0,0,0,0.3);
    }
        .mode-switch { display: inline-flex; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.12); border-radius: 999px; overflow: hidden; align-items: center; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04); }
        .mode-tab { font-size: 10px; padding: 3px 7px; letter-spacing: .3px; }
        .mode-tab.active { background: linear-gradient(135deg, #ff1a78, #ff0066); color: #fff; box-shadow: inset 0 0 12px rgba(255, 26, 120, 0.3); }
    .account-btn { width: 30px; height: 30px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.06); cursor: pointer; }
    .account-btn.has-photo { background-size: cover; background-position: center; }
    .account-btn.connected { border-color: #00ff88; box-shadow: 0 0 0 1px rgba(0,255,136,0.25), inset 0 0 8px rgba(0,255,136,0.15); }
        @media (max-width: 768px) {
            .site-header { padding: 6px 10px; }
            .header-inner { flex-wrap: nowrap; }
            .countdown-container { display: none; }
            .header-link { padding: 7px 10px; font-size: 12px; }
            .mode-tab { font-size: 9px; padding: 3px 6px; }
        }
        @media (max-width: 480px) {
            .header-inner { gap: 6px; }
            .logo-container { flex: 0 0 auto; }
            .header-nav { flex: 1 1 auto; justify-content: flex-end; }
        }
    </style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
<!-- SoundFactory SMS Modal assets -->
<link rel="stylesheet" href="https://seance.soundfactorynyc.com/public/sf-sms-modal.css" />
<script>
    // Point to the correct SMS microservice
    window.SMS_API_BASE = 'https://sf-sms-service.netlify.app';
    // Disable auto init; we will instantiate and wire callbacks ourselves
    window.SF_SMS_MODAL_AUTO_INIT = false;
    // Optional: expose a hook for other scripts
    window.__sf_sms_ready = false;
    const isLocal = ['localhost', '127.0.0.1', '0.0.0.0'].includes(location.hostname) || location.hostname.endsWith('.local');
    window.addEventListener('sf:sdk-ready', () => { window.__sf_sms_ready = true; });

    // Normalize cookie and notify gate when auth happens
    window.addEventListener('sf:auth', async (e) => {
        try {
            const token = e?.detail?.token;
            const phone = e?.detail?.phone;
            if (token) {
                document.cookie = 'sf_token=' + token + '; path=/';
            }
            if (window.smsGate) {
                window.smsGate.isVerified = true;
                if (typeof window.smsGate.enableFeatures === 'function') window.smsGate.enableFeatures();
            }
            // Lightly persist phone for UX and reflect connected
            try {
                if (phone) localStorage.setItem('sf_phone', phone);
                // Create or retrieve Stripe customer for this user
                try {
                    const name = (window.currentUser?.name) || (JSON.parse(localStorage.getItem('sf_user')||'{}').name) || '';
                    const res = await fetch('/.netlify/functions/ensure-customer', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ phone, name })
                    });
                    if (res.ok) {
                        const data = await res.json();
                        if (data?.customerId) localStorage.setItem('sf_customer_id', data.customerId);
                    }
                } catch (custErr) { console.warn('ensure-customer failed', custErr); }
                const acctBtnEl = document.getElementById('accountBtn');
                if (acctBtnEl) acctBtnEl.classList.add('connected');
                document.getElementById('smsVerificationBanner')?.remove();
                document.getElementById('smsVerificationOverlay')?.remove();
                document.getElementById('acctVerify')?.setAttribute('disabled','true');
                document.getElementById('onVerify')?.setAttribute('disabled','true');
                if (typeof showNotification === 'function') showNotification('✅ Connected via SMS', '#00ff88');
            } catch {}
        } catch (err) { console.warn('sf:auth handler failed', err); }
    });

    // Initialize SMS modal/auth
    try {
        if (isLocal) {
            // Force bypass during local dev so page is visible
            try { localStorage.setItem('sf_bypass','true'); } catch {}
        }
        window.sfAuth = new SoundFactorySMSAuth({
            apiBase: window.SMS_API_BASE || 'https://sf-sms-service.netlify.app',
            autoShowModal: !isLocal,
            // Soft gate: do not block page interactivity before login
            requireAuth: false,
            onAuthSuccess: ({ token, phone }) => {
                try { document.cookie = 'sf_token=' + token + '; path=/'; } catch {}
                if (window.smsGate) { window.smsGate.isVerified = true; window.smsGate.enableFeatures?.(); }
                window.dispatchEvent(new CustomEvent('sf:auth', { detail: { token, phone } }));
                // Reflect UI immediately
                try { document.getElementById('accountBtn')?.classList.add('connected'); } catch {}
                // After verification, prompt for display name (once); no auto overlay
                try {
                    const storedRaw = localStorage.getItem('sf_user');
                    let stored = storedRaw ? JSON.parse(storedRaw) : {};
                    if (!stored.name || /#\w{3}$/i.test(stored.name)) {
                        const name = prompt('Enter your display name (what others will see):', stored.name || '');
                        if (name && name.trim()) {
                            stored.name = name.trim();
                            localStorage.setItem('sf_user', JSON.stringify(stored));
                            if (window.currentUser) window.currentUser.name = stored.name;
                        }
                    }
                } catch {}
            },
            onAuthFailure: (err) => {
                console.warn('Auth failed:', err?.message || err);
            }
        });
        // Helper to open the SMS modal on demand, trying common method names
        window.openSMSModal = function() {
            try {
                if (window.sfAuth && typeof window.sfAuth.show === 'function') return window.sfAuth.show();
                if (window.sfAuth && typeof window.sfAuth.open === 'function') return window.sfAuth.open();
                if (window.sfAuth && typeof window.sfAuth.showModal === 'function') return window.sfAuth.showModal();
                // Fallback: emit an event some SDKs listen for
                window.dispatchEvent(new CustomEvent('sf:sms-open'));
            } catch(e) { console.warn('Could not open SMS modal', e); }
        }
    } catch (e) { console.warn('SMS modal init failed', e); }
    // Minimal direct API helpers as a fallback when the modal SDK is not available
    window.sfSMS = {
        sendCode: async (phone) => {
            const primary = `${window.SMS_API_BASE}/.netlify/functions/send-code`;
            try {
                const res = await fetch(primary, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ phone }) });
                if (!res.ok) throw new Error(String(res.status));
                return res.json();
            } catch (e) {
                // Fall back to local proxy to avoid CORS issues during testing
                const proxy = '/.netlify/functions/sms-send-code';
                const res2 = await fetch(proxy, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ phone }) });
                if (!res2.ok) throw new Error(`proxy send-code failed ${res2.status}`);
                return res2.json();
            }
        },
        verifyCode: async (phone, code) => {
            const primary = `${window.SMS_API_BASE}/.netlify/functions/verify-code`;
            try {
                const res = await fetch(primary, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ phone, code }) });
                if (!res.ok) throw new Error(String(res.status));
                return res.json();
            } catch (e) {
                const proxy = '/.netlify/functions/sms-verify-code';
                const res2 = await fetch(proxy, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ phone, code }) });
                if (!res2.ok) throw new Error(`proxy verify-code failed ${res2.status}`);
                return res2.json();
            }
        }
    };

        // Optional helper to kick off Stripe Checkout for small items, reusing customerId
        window.startCheckout = async (opts={}) => {
            try {
                const customerId = localStorage.getItem('sf_customer_id') || undefined;
                const user = JSON.parse(localStorage.getItem('sf_user')||'{}');
                const payload = {
                    item: opts.item || 'drink',
                    amount: opts.amount,
                    currency: opts.currency || 'usd',
                    priceId: opts.priceId,
                    userId: user.id || '',
                    userName: user.name || '',
                    customerId
                };
                const res = await fetch('/.netlify/functions/create-checkout-session', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const data = await res.json();
                if (data?.url) location.href = data.url;
                return data;
            } catch (e) { console.warn('checkout failed', e); }
        };

        // Backfill: if we already have a phone but no Stripe customer, create it on load
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                const phone = localStorage.getItem('sf_phone');
                const existing = localStorage.getItem('sf_customer_id');
                if (phone && !existing) {
                    const name = (window.currentUser?.name) || (JSON.parse(localStorage.getItem('sf_user')||'{}').name) || '';
                    const res = await fetch('/.netlify/functions/ensure-customer', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ phone, name })
                    });
                    if (res.ok) {
                        const data = await res.json();
                        if (data?.customerId) localStorage.setItem('sf_customer_id', data.customerId);
                    }
                }
            } catch (e) { console.warn('ensure-customer onload failed', e); }
        });
</script>
    <script src="https://seance.soundfactorynyc.com/public/sf-sms-modal.js" defer></script>
    <script src="js/sf-fan-tracker.js" defer></script>
    <link rel="stylesheet" href="css/grid.css">
    <!-- <script src="js/grid.js" defer></script> --> <!-- Grid system removed -->
    <!-- <script src="js/ai-monitor.js" defer></script> --> <!-- AI monitor removed as requested -->
    <script src="js/websocket-client.js" defer></script>
    <script src="https://cdn.skypack.dev/@supabase/supabase-js@2"></script>
    <script src="js/social-media-embed.js" defer></script>
</head>
<body>
    <!-- Supabase Initialization -->
    <script>
        // Supabase Configuration
        const SUPABASE_CONFIG = {
            url: 'https://your-project.supabase.co', // Replace with your actual Supabase URL
            anonKey: 'your-anon-key-here' // Replace with your actual anon key
        };

        // Initialize Supabase client
        let supabase;
        try {
            // Wait for Supabase to load
            if (typeof window.supabase !== 'undefined' && window.supabase.createClient) {
                supabase = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
                console.log('✅ Supabase client initialized');
            } else {
                console.warn('⚠️ Supabase not loaded yet, will retry...');
                // Retry after a short delay
                setTimeout(() => {
                    if (typeof window.supabase !== 'undefined' && window.supabase.createClient) {
                        supabase = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
                        console.log('✅ Supabase client initialized (retry)');
                    } else {
                        console.error('❌ Supabase still not available after retry');
                    }
                }, 1000);
            }
        } catch (error) {
            console.error('❌ Supabase initialization failed:', error);
        }

        // Make supabase globally available
        window.supabase = supabase;
    </script>

    <!-- Header with text wordmark and tightened spacing -->
    <header class="site-header">
        <div class="header-inner">
            <div class="logo-container">
                <div class="brand-wordmark" aria-label="Brand">
                    <span class="brand-strong">SOUND&nbsp;FACTORY</span>
                </div>
                <div class="countdown-container">
                    <div class="countdown-label">Opening in</div>
                    <div class="countdown-timer" id="countdown">Loading...</div>
                </div>
            </div>
            <nav class="header-nav">
                <div class="mode-switch" id="modeSwitch" role="tablist" aria-label="Mode">
                    <button class="mode-tab active" data-mode="find" role="tab" aria-selected="true">Find Friends</button>
                    <button class="mode-tab" data-mode="drop" role="tab" aria-selected="false">Drop Pin</button>
                </div>
                <button id="accountBtn" class="account-btn" aria-label="Account"></button>
                <a href="tables.html" class="header-link tables">Tables</a>
                <a href="ai-audio-sampler.html" class="header-link ai-tools">🎵 AI Sampler</a>
                <a href="ai-vocal-studio.html" class="header-link ai-tools">🎤 AI Studio</a>
                <a href="https://soundfactory.ticketspice.com/soundfactory-sance" class="header-link tickets" target="_blank" rel="noopener">Tickets</a>
            </nav>
        </div>
    </header>
    <!-- Hidden file input for profile picture -->
    <input type="file" id="photoInput" accept="image/*" capture="environment" style="display:none" />

    <!-- Account Modal -->
    <div id="accountModal" class="onboard-overlay" role="dialog" aria-modal="true" aria-labelledby="acctTitle" style="display:none;">
        <div class="onboard-card">
            <div class="onboard-head">
                <div class="onboard-logo" aria-hidden="true"></div>
                <div>
                    <div class="onboard-title" id="acctTitle">Your Account</div>
                    <div style="font-size:11px; color:#7e8a99;">Name & Photo are what others see</div>
                </div>
            </div>
            <div class="onboard-actions" style="grid-template-columns: 1fr;">
                <input id="acctName" class="on-btn" style="text-align:left;" placeholder="Display name" />
                <button class="on-btn" id="acctUpload">📸 Upload Photo</button>
                <button class="on-btn" id="acctVerify">🔐 Verify Phone</button>
                <button class="on-btn" id="acctClose">Close</button>
            </div>
        </div>
    </div>

    <!-- Onboarding overlay -->
    <div id="onboardOverlay" class="onboard-overlay" role="dialog" aria-modal="true" aria-labelledby="onboardTitle">
        <div class="onboard-card">
            <div class="onboard-head">
                <div class="onboard-logo" aria-hidden="true"></div>
                <div>
                    <div class="onboard-title" id="onboardTitle">Welcome to Sound Factory</div>
                    <div style="font-size:11px; color:#7e8a99;">Find or Drop a Pin to start</div>
                </div>
            </div>
            <div class="onboard-copy">
                If you want to drop a pin, flip to Drop and tap the map. Add your picture to your profile now, or we’ll use the Sound Factory logo by default. You can verify your phone anytime to unlock everything.
            </div>
            <div class="onboard-actions">
                <button class="on-btn" id="onAddPhoto">📸 Upload Photo</button>
                <button class="on-btn primary" id="onGoDrop">📍 Go to Drop</button>
                <button class="on-btn" id="onVerify">🔐 Verify Phone</button>
                <button class="on-btn" id="onFind">🔎 Stay in Find</button>
            </div>
            <div class="onboard-foot">
                <button class="on-skip" id="onSkip">Skip for now</button>
                <div class="on-note">You can update this later from the header.</div>
            </div>
        </div>
    </div>
    
    <!-- Navigation Links - Top Right (Removed as replaced by header) -->

    <!-- Main Content Area -->
    <div class="main-content">
        <div class="floor-container">
            <!-- Basement -->
            <div class="floor" id="floor-b">
                <!-- Large flyer banner removed as requested -->
                <svg class="floor-svg" viewBox="0 0 400 520" preserveAspectRatio="xMidYMid slice">
                    <defs>
                        <filter id="basementGlow">
                            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    
                    <rect width="400" height="520" fill="#000"/>
                    <rect x="5" y="5" width="390" height="510" fill="none" stroke="#333" stroke-width="2" filter="url(#basementGlow)"/>
                    <rect x="10" y="10" width="380" height="500" fill="#050505" stroke="#222" stroke-width="1"/>
                    <rect x="30" y="30" width="340" height="460" fill="none" stroke="#444" stroke-width="2"/>
                    
                    <rect x="180" y="35" width="140" height="45" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="185" y="40" width="130" height="35" fill="none" stroke="#333" stroke-width="1"/>
                    
                    <rect x="35" y="35" width="60" height="80" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="40" y="40" width="50" height="70" fill="none" stroke="#333" stroke-width="1"/>
                    
                    <rect x="35" y="120" width="60" height="60" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="35" y="320" width="60" height="60" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="35" y="385" width="60" height="100" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="40" y="390" width="50" height="90" fill="none" stroke="#333" stroke-width="1"/>
                    
                    <rect x="110" y="100" width="180" height="320" fill="none" stroke="#333" stroke-width="1" stroke-dasharray="5,5" opacity="0.5"/>
                    
                    <rect x="140" y="140" width="20" height="20" fill="#000" stroke="#444" stroke-width="2"/>
                    <rect x="240" y="140" width="20" height="20" fill="#000" stroke="#444" stroke-width="2"/>
                    <rect x="140" y="240" width="20" height="20" fill="#000" stroke="#444" stroke-width="2"/>
                    <rect x="240" y="240" width="20" height="20" fill="#000" stroke="#444" stroke-width="2"/>
                    <rect x="140" y="340" width="20" height="20" fill="#000" stroke="#444" stroke-width="2"/>
                    <rect x="240" y="340" width="20" height="20" fill="#000" stroke="#444" stroke-width="2"/>
                    
                    <rect x="305" y="120" width="60" height="60" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="310" y="125" width="50" height="50" fill="none" stroke="#333" stroke-width="1"/>
                    
                    <rect x="305" y="185" width="60" height="60" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="305" y="250" width="60" height="60" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="310" y="255" width="50" height="50" fill="none" stroke="#333" stroke-width="1"/>
                    
                    <rect x="305" y="315" width="60" height="60" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="305" y="380" width="60" height="60" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="310" y="385" width="50" height="50" fill="none" stroke="#333" stroke-width="1"/>
                    
                    <rect x="120" y="440" width="160" height="45" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="125" y="445" width="150" height="35" fill="none" stroke="#333" stroke-width="1"/>
                    
                    <path d="M180,485 L180,475 L220,475 L220,485" stroke="#666" stroke-width="2" fill="none" stroke-dasharray="2,2"/>
                </svg>
                <div class="floor-hint" aria-hidden="true"></div>
                <!-- Characters Container for Basement -->
                <div class="characters-container" id="characters-b"></div>
            </div>

            <!-- Main Floor -->
            <div class="floor active" id="floor-mf">
                <!-- Large flyer banner removed as requested -->
                <svg class="floor-svg" viewBox="0 0 400 520" preserveAspectRatio="xMidYMid slice">
                    <defs>
                    </defs>
                    
                    <!-- Floor base -->
                    <rect width="400" height="520" fill="#000"/>
                    <rect x="5" y="5" width="390" height="510" fill="none" stroke="#333" stroke-width="2"/>
                    <rect x="10" y="10" width="380" height="500" fill="#050505"/>
                    
                    <!-- Stairs (Top) - Made Wider with Railing -->
                    <g opacity="0.6">
                        <rect x="150" y="20" width="100" height="35" fill="#0a0a0a" stroke="#555" stroke-width="2"/>
                        <path d="M155 25 L245 25 M155 30 L245 30 M155 35 L245 35 M155 40 L245 40 M155 45 L245 45 M155 50 L245 50" stroke="#444"/>
                        <!-- Stair Railing -->
                        <line x1="200" y1="20" x2="200" y2="55" stroke="#666" stroke-width="3"/>
                        <line x1="195" y1="25" x2="205" y2="25" stroke="#666" stroke-width="2"/>
                        <line x1="195" y1="35" x2="205" y2="35" stroke="#666" stroke-width="2"/>
                        <line x1="195" y1="45" x2="205" y2="45" stroke="#666" stroke-width="2"/>
                        <text x="200" y="40" font-family="Arial" font-size="8" fill="#888" text-anchor="middle">STAIRS</text>
                    </g>
                    
                    <!-- Realistic Disco Ball (Between Top Left Columns) -->
                    <g id="discoBall" transform="translate(200, 150)">
                        <!-- Main disco ball sphere -->
                        <circle cx="0" cy="0" r="40" fill="url(#discoGradient)" stroke="#333" stroke-width="2"/>
                        
                        <!-- Simple disco ball - one round part -->
                        
                        <!-- Light reflections -->
                        <circle cx="-15" cy="-20" r="3" fill="#ffffff" opacity="0.9"/>
                        <circle cx="10" cy="-25" r="2" fill="#ffffff" opacity="0.8"/>
                        <circle cx="20" cy="-10" r="2.5" fill="#ffffff" opacity="0.7"/>
                        <circle cx="-5" cy="5" r="2" fill="#ffffff" opacity="0.6"/>
                        <circle cx="15" cy="8" r="1.5" fill="#ffffff" opacity="0.8"/>
                        
                        <!-- Hanging chain -->
                        <line x1="0" y1="-40" x2="0" y2="-50" stroke="#666" stroke-width="2"/>
                        <circle cx="0" cy="-50" r="3" fill="#333"/>
                    </g>
                    
                    <!-- Disco ball gradient definition -->
                    <defs>
                        <radialGradient id="discoGradient" cx="0.3" cy="0.3" r="0.8">
                            <stop offset="0%" stop-color="#ffffff"/>
                            <stop offset="30%" stop-color="#e0e0e0"/>
                            <stop offset="60%" stop-color="#c0c0c0"/>
                            <stop offset="100%" stop-color="#808080"/>
                        </radialGradient>
                    </defs>
                    
                    <!-- Columns (3x4 grid) -->
                    <g>
                        <!-- Row 1 -->
                        <rect x="80" y="100" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        <rect x="185" y="100" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        <rect x="290" y="100" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        
                        <!-- Row 2 -->
                        <rect x="80" y="200" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        <rect x="185" y="200" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        <rect x="290" y="200" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        
                        <!-- Row 3 -->
                        <rect x="80" y="300" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        <rect x="185" y="300" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        <rect x="290" y="300" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        
                        <!-- Row 4 -->
                        <rect x="80" y="400" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        <rect x="185" y="400" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                        <rect x="290" y="400" width="30" height="30" fill="#000" stroke="#666" stroke-width="2" rx="2"/>
                    </g>
                    
                    
                    <!-- Stage Piece 1 (Draggable - Top Half) -->
                    <g id="draggableStage1" style="cursor: move;">
                        <rect x="150" y="400" width="30" height="100" fill="#000" stroke="#000" stroke-width="3" rx="8"/>
                        <rect x="155" y="405" width="20" height="90" fill="#000" stroke="#000" stroke-width="1" rx="4"/>
                        <!-- Stage lights - Top half -->
                        <circle cx="165" cy="420" r="2" fill="#ff6b35" opacity="0.8"/>
                        <circle cx="165" cy="440" r="2" fill="#ff6b35" opacity="0.8"/>
                        <circle cx="165" cy="460" r="2" fill="#ff6b35" opacity="0.8"/>
                        <circle cx="165" cy="480" r="2" fill="#ff6b35" opacity="0.8"/>
                        <circle cx="165" cy="500" r="2" fill="#ff6b35" opacity="0.8"/>
                    </g>
                    
                    <!-- Stage Piece 2 (Draggable - Bottom Half) -->
                    <g id="draggableStage2" style="cursor: move;">
                        <rect x="150" y="500" width="30" height="100" fill="#000" stroke="#000" stroke-width="3" rx="8"/>
                        <rect x="155" y="505" width="20" height="90" fill="#000" stroke="#000" stroke-width="1" rx="4"/>
                        <!-- Stage lights - Bottom half -->
                        <circle cx="165" cy="520" r="2" fill="#ff6b35" opacity="0.8"/>
                        <circle cx="165" cy="540" r="2" fill="#ff6b35" opacity="0.8"/>
                        <circle cx="165" cy="560" r="2" fill="#ff6b35" opacity="0.8"/>
                        <circle cx="165" cy="580" r="2" fill="#ff6b35" opacity="0.8"/>
                        <circle cx="165" cy="600" r="2" fill="#ff6b35" opacity="0.8"/>
                    </g>
                    
                    <!-- Bar (Diagonal from bottom left to third column) -->
                    <g opacity="0.3">
                        <path d="M 20 450 L 200 300 L 220 300 L 40 450 Z" fill="#0f0f1f" stroke="#004e92" stroke-width="2"/>
                        <!-- Bar counter edge -->
                        <line x1="20" y1="450" x2="40" y2="450" stroke="#004e92" stroke-width="3"/>
                        <line x1="200" y1="300" x2="220" y2="300" stroke="#004e92" stroke-width="3"/>
                    </g>
                    
                    
                    <!-- Dance floor grid -->
                    <g opacity="0.05">
                        <path d="M60 150 L340 150 M60 230 L340 230 M60 310 L340 310 M60 390 L340 390" stroke="#222"/>
                        <path d="M130 80 L130 450 M200 80 L200 450 M270 80 L270 450" stroke="#222"/>
                    </g>
                    
                    <!-- Exit (Bottom) -->
                    <g opacity="0.6">
                        <rect x="170" y="475" width="60" height="25" fill="none" stroke="#555" stroke-width="2"/>
                        <text x="200" y="492" font-family="Arial" font-size="8" fill="#888" text-anchor="middle">EXIT</text>
                    </g>
                </svg>
                <div class="floor-hint" aria-hidden="true"></div>
                <!-- Characters Container for Main Floor -->
                <div class="characters-container" id="characters-mf"></div>
            </div>

            <!-- Mezzanine -->
            <div class="floor" id="floor-mz">
                <!-- Large flyer banner removed as requested -->
                <svg class="floor-svg" viewBox="0 0 400 520" preserveAspectRatio="xMidYMid slice">
                    <rect width="400" height="520" fill="#000"/>
                    
                    <rect x="5" y="5" width="390" height="510" fill="none" stroke="#555" stroke-width="3"/>
                    <rect x="10" y="10" width="380" height="500" fill="#050505" stroke="#555" stroke-width="2"/>
                    
                    <rect x="35" y="35" width="330" height="450" fill="#0a0a0a" stroke="#666" stroke-width="3"/>
                    
                    <rect x="100" y="100" width="200" height="250" fill="#000" stroke="#444" stroke-width="2"/>
                    <text x="200" y="225" font-family="Arial" font-size="11" fill="#666" text-anchor="middle" opacity="0.8">
                        OPEN TO BELOW
                    </text>
                    
                    <rect x="175" y="45" width="50" height="50" fill="#0f0f0f" stroke="#777" stroke-width="2"/>
                    <rect x="175" y="425" width="50" height="50" fill="#0f0f0f" stroke="#777" stroke-width="2"/>
                    <rect x="250" y="170" width="50" height="70" fill="#0f0f0f" stroke="#666" stroke-width="2"/>
                    <rect x="320" y="45" width="35" height="35" fill="#1a0000" stroke="#aa3333" stroke-width="2" opacity="0.8"/>
                    
                    <rect x="45" y="130" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    <rect x="45" y="170" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    <rect x="45" y="210" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    <rect x="45" y="250" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    <rect x="45" y="290" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    
                    <rect x="310" y="130" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    <rect x="310" y="170" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    <rect x="310" y="210" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    <rect x="310" y="250" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    <rect x="310" y="290" width="45" height="30" fill="none" stroke="#555" stroke-width="2" rx="2"/>
                    
                    <circle cx="75" cy="95" r="6" fill="#000" stroke="#666" stroke-width="2"/>
                    <circle cx="325" cy="95" r="6" fill="#000" stroke="#666" stroke-width="2"/>
                    <circle cx="75" cy="355" r="6" fill="#000" stroke="#666" stroke-width="2"/>
                    <circle cx="325" cy="355" r="6" fill="#000" stroke="#666" stroke-width="2"/>
                </svg>
                <div class="floor-hint" aria-hidden="true"></div>
                <!-- Characters Container for Mezzanine -->
                <div class="characters-container" id="characters-mz"></div>
            </div>

            <!-- Second Floor -->
            <div class="floor" id="floor-2">
                <!-- Large flyer banner removed as requested -->
                <svg class="floor-svg" viewBox="0 0 400 520" preserveAspectRatio="xMidYMid slice">
                    <rect width="400" height="520" fill="#000"/>
                    
                    <rect x="5" y="5" width="390" height="510" fill="none" stroke="#888" stroke-width="4"/>
                    <rect x="10" y="10" width="380" height="500" fill="#000" stroke="#666" stroke-width="3"/>
                    
                    <rect x="30" y="30" width="140" height="100" fill="#000" stroke="#666" stroke-width="2"/>
                    <rect x="30" y="30" width="140" height="35" fill="#0a0a0a" stroke="#555" stroke-width="1"/>
                    <rect x="30" y="65" width="70" height="65" fill="none" stroke="#444" stroke-width="1"/>
                    <rect x="100" y="65" width="70" height="65" fill="none" stroke="#444" stroke-width="1"/>
                    
                    <rect x="170" y="50" width="60" height="80" fill="#0a0a0a" stroke="#777" stroke-width="2"/>
                    <rect x="230" y="50" width="60" height="80" fill="#0a0a0a" stroke="#777" stroke-width="2"/>
                    
                    <rect x="290" y="30" width="80" height="100" fill="#000" stroke="#666" stroke-width="2"/>
                    <line x1="290" y1="60" x2="370" y2="60" stroke="#444" stroke-width="1"/>
                    <line x1="290" y1="90" x2="370" y2="90" stroke="#444" stroke-width="1"/>
                    <line x1="330" y1="30" x2="330" y2="130" stroke="#444" stroke-width="1"/>
                    
                    <rect x="30" y="150" width="60" height="300" fill="#000" stroke="#666" stroke-width="2"/>
                    
                    <rect x="120" y="180" width="160" height="160" fill="none" stroke="#555" stroke-width="2" stroke-dasharray="4,4"/>
                    <text x="200" y="260" font-family="Arial" font-size="11" fill="#666" text-anchor="middle" opacity="0.8">
                        OPEN SPACE
                    </text>
                    
                    <circle cx="105" cy="165" r="8" fill="#000" stroke="#666" stroke-width="2"/>
                    <circle cx="105" cy="220" r="8" fill="#000" stroke="#666" stroke-width="2"/>
                    <circle cx="105" cy="275" r="8" fill="#000" stroke="#666" stroke-width="2"/>
                    <circle cx="105" cy="330" r="8" fill="#000" stroke="#666" stroke-width="2"/>
                    
                    <circle cx="295" cy="165" r="8" fill="#000" stroke="#666" stroke-width="2"/>
                    <circle cx="295" cy="220" r="8" fill="#000" stroke="#666" stroke-width="2"/>
                    <circle cx="295" cy="275" r="8" fill="#000" stroke="#666" stroke-width="2"/>
                    <circle cx="295" cy="330" r="8" fill="#000" stroke="#666" stroke-width="2"/>
                    
                    <rect x="310" y="180" width="60" height="160" fill="#000" stroke="#666" stroke-width="2"/>
                    <rect x="320" y="190" width="40" height="30" fill="none" stroke="#444" stroke-width="1" rx="2"/>
                    <rect x="320" y="230" width="40" height="30" fill="none" stroke="#444" stroke-width="1" rx="2"/>
                    <rect x="320" y="270" width="40" height="30" fill="none" stroke="#444" stroke-width="1" rx="2"/>
                    <rect x="320" y="310" width="40" height="30" fill="none" stroke="#444" stroke-width="1" rx="2"/>
                    
                    <rect x="120" y="390" width="160" height="80" fill="#0a0a0a" stroke="#777" stroke-width="2"/>
                    
                    <rect x="310" y="410" width="60" height="60" fill="#000" stroke="#666" stroke-width="2"/>
                    <line x1="325" y1="425" x2="355" y2="455" stroke="#555" stroke-width="2"/>
                    <line x1="355" y1="425" x2="325" y2="455" stroke="#555" stroke-width="2"/>
                    
                    <rect x="310" y="480" width="20" height="10" fill="none" stroke="#777" stroke-width="2" stroke-dasharray="2,2"/>
                    <rect x="350" y="480" width="20" height="10" fill="none" stroke="#777" stroke-width="2" stroke-dasharray="2,2"/>
                </svg>
                <div class="floor-hint" aria-hidden="true"></div>
                <!-- Characters Container for Second Floor -->
                <div class="characters-container" id="characters-2"></div>
            </div>

            <!-- Third Floor -->
            <div class="floor" id="floor-3">
                <!-- Large flyer banner removed as requested -->
                <svg class="floor-svg" viewBox="0 0 400 520" preserveAspectRatio="xMidYMid slice">
                    <rect width="400" height="520" fill="#000"/>
                    
                    <rect x="5" y="5" width="390" height="510" fill="none" stroke="#555" stroke-width="3"/>
                    <rect x="10" y="10" width="380" height="500" fill="#050505" stroke="#444" stroke-width="2"/>
                    
                    <rect x="30" y="30" width="340" height="460" fill="none" stroke="#666" stroke-width="2"/>
                    
                    <rect x="100" y="140" width="200" height="180" fill="#000" stroke="#555" stroke-width="2"/>
                    
                    <rect x="150" y="35" width="100" height="80" fill="#000" stroke="#666" stroke-width="2"/>
                    <path d="M170,70 Q200,60 230,70" fill="none" stroke="#555" stroke-width="2"/>
                    <path d="M170,90 Q200,80 230,90" fill="none" stroke="#555" stroke-width="2"/>
                    
                    <rect x="35" y="35" width="60" height="80" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="35" y="180" width="60" height="80" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="35" y="350" width="60" height="80" fill="#000" stroke="#555" stroke-width="2"/>
                    
                    <rect x="305" y="35" width="60" height="80" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="305" y="180" width="60" height="80" fill="#000" stroke="#555" stroke-width="2"/>
                    <rect x="305" y="350" width="60" height="80" fill="#000" stroke="#555" stroke-width="2"/>
                    
                    <rect x="120" y="390" width="160" height="80" fill="#000" stroke="#666" stroke-width="2"/>
                    
                    <rect x="35" y="440" width="40" height="40" fill="#000" stroke="#555" stroke-width="2"/>
                    <line x1="45" y1="450" x2="65" y2="470" stroke="#444" stroke-width="2"/>
                    <line x1="65" y1="450" x2="45" y2="470" stroke="#444" stroke-width="2"/>
                    
                    <rect x="325" y="440" width="40" height="40" fill="#000" stroke="#555" stroke-width="2"/>
                    
                    <path d="M180,485 L180,475 L220,475 L220,485" stroke="#666" stroke-width="2" fill="none" stroke-dasharray="2,2"/>
                </svg>
                <div class="floor-hint" aria-hidden="true"></div>
                <!-- Characters Container for Third Floor -->
                <div class="characters-container" id="characters-3"></div>
            </div>
        </div>
    </div>

        <!-- Enhanced Pin Creation Modal -->
        <div id="pinCreationModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; backdrop-filter: blur(10px);">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(20,20,20,0.95), rgba(40,40,60,0.95)); border: 2px solid #ff6b00; border-radius: 20px; padding: 30px; max-width: 400px; width: 90%; box-shadow: 0 20px 40px rgba(0,0,0,0.5);">
                <div style="text-align: center; margin-bottom: 20px;">
                    <h3 style="color: #ff6b00; margin: 0; font-size: 24px; font-weight: 700;">Drop Your Pin</h3>
                    <p style="color: #ccc; margin: 10px 0 0 0; font-size: 14px;">Share what's happening here</p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #fff; margin-bottom: 8px; font-weight: 600;">Your Story</label>
                    <textarea id="pinMessage" placeholder="Tell your story for this pin..." style="width: 100%; height: 80px; padding: 12px; border: 1px solid #333; border-radius: 8px; background: rgba(0,0,0,0.3); color: #fff; font-size: 14px; resize: none; outline: none;" maxlength="200"></textarea>
                    <div style="text-align: right; color: #666; font-size: 12px; margin-top: 4px;">
                        <span id="charCount">0</span>/200
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #fff; margin-bottom: 8px; font-weight: 600;">Pin Type</label>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                        <button class="pin-type-btn" data-type="moment" style="padding: 12px; border: 2px solid #ff6b00; background: rgba(255,107,0,0.1); color: #ff6b00; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                            🎉 Moment
            </button>
                        <button class="pin-type-btn" data-type="meet" style="padding: 12px; border: 2px solid #00ff88; background: rgba(0,255,136,0.1); color: #00ff88; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                            👥 Meet
            </button>
                        <button class="pin-type-btn" data-type="vibe" style="padding: 12px; border: 2px solid #ffd700; background: rgba(255,215,0,0.1); color: #ffd700; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                            🎵 Vibe
            </button>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button id="createPinBtn" style="flex: 1; padding: 15px; background: linear-gradient(135deg, #ff6b00, #ff8c00); color: white; border: none; border-radius: 8px; font-weight: 700; font-size: 16px; cursor: pointer; transition: all 0.3s;">
                        DROP PIN
            </button>
                    <button id="cancelPinBtn" style="flex: 1; padding: 15px; background: rgba(255,255,255,0.1); color: #ccc; border: 1px solid #333; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                        Cancel
            </button>
                </div>
        </div>
    </div>

        <!-- Pin Hover Card -->
        <div id="pinHoverCard" style="display: none; position: fixed; background: rgba(0,0,0,0.95); border: 1px solid #ff6b00; border-radius: 12px; padding: 15px; min-width: 250px; z-index: 500; pointer-events: none;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <div id="hoverAvatar" style="width: 40px; height: 40px; border-radius: 50%; background: #ff6b00; border: 2px solid #ff6b00;"></div>
                <div>
                    <div id="hoverName" style="font-size: 16px; font-weight: 600; color: #ff6b00;">-</div>
                </div>
            </div>
            <div id="hoverStory" style="color: #aaa; font-size: 13px; line-height: 1.5; margin-bottom: 10px;">-</div>
            <div style="display: flex; gap: 10px;">
                <button onclick="likePin()" style="flex: 1; padding: 6px 12px; background: rgba(255,107,0,0.2); border: 1px solid rgba(255,107,0,0.3); border-radius: 6px; color: #ff6b00; font-size: 12px; cursor: pointer;">❤️ Like</button>
                <button onclick="sharePin()" style="flex: 1; padding: 6px 12px; background: rgba(255,107,0,0.2); border: 1px solid rgba(255,107,0,0.3); border-radius: 6px; color: #ff6b00; font-size: 12px; cursor: pointer;">📤 Share</button>
                <button onclick="commentPin()" style="flex: 1; padding: 6px 12px; background: rgba(255,107,0,0.2); border: 1px solid rgba(255,107,0,0.3); border-radius: 6px; color: #ff6b00; font-size: 12px; cursor: pointer;">💬 Comment</button>
        </div>
    </div>

    <!-- Footer removed as requested -->

    <!-- Floor navigation removed - using swipe controls instead -->

    <!-- Character system removed as requested -->


    <!-- Other Characters Container -->
    <div id="othersContainer"></div>

    <!-- Group Chat removed -->

    

    <!-- Controls removed: modes and +Add are no longer shown -->


    <!-- Status -->
    <div class="status">
        <div>People: <span class="people-count" id="peopleCount">1</span></div>
    </div>

    <!-- Premium Chat UI fully removed; no modular component is loaded -->

    <!-- Live Stream Share Button -->
    <button class="live-share-btn" id="liveShareBtn" title="Share Live Stream">📡</button>

    <!-- AI Studio and AI Sampler Buttons - Bottom Right -->
    <button class="ai-studio-btn" id="aiStudioBtn" title="AI Vocal Studio">🎤</button>
    <button class="ai-sampler-btn" id="aiSamplerBtn" title="AI Audio Sampler">🎛️</button>

    <!-- Identity Selection Modal -->
    <div id="identityModal" class="identity-modal">
        <div class="identity-content">
            <h2 class="identity-title">Who Are You Tonight?</h2>
            <p class="identity-subtitle">Choose how you want to express yourself</p>
            <div class="identity-options">
                <button class="identity-option" data-identity="person" data-gender="any">
                    <div class="identity-icon">👤</div>
                    <div class="identity-label">Person</div>
                </button>
                <button class="identity-option" data-identity="energy" data-type="fire">
                    <div class="identity-icon">🔥</div>
                    <div class="identity-label">Fire Energy</div>
                </button>
                <button class="identity-option" data-identity="energy" data-type="water">
                    <div class="identity-icon">🌊</div>
                    <div class="identity-label">Water Flow</div>
                </button>
                <button class="identity-option" data-identity="energy" data-type="air">
                    <div class="identity-icon">💨</div>
                    <div class="identity-label">Air Spirit</div>
                </button>
                <button class="identity-option" data-identity="energy" data-type="earth">
                    <div class="identity-icon">🌍</div>
                    <div class="identity-label">Earth Ground</div>
                </button>
                <button class="identity-option" data-identity="creature" data-type="dragon">
                    <div class="identity-icon">🐉</div>
                    <div class="identity-label">Dragon</div>
                </button>
                <button class="identity-option" data-identity="creature" data-type="phoenix">
                    <div class="identity-icon">🔥</div>
                    <div class="identity-label">Phoenix</div>
                </button>
                <button class="identity-option" data-identity="creature" data-type="unicorn">
                    <div class="identity-icon">🦄</div>
                    <div class="identity-label">Unicorn</div>
                </button>
                <button class="identity-option" data-identity="abstract" data-type="light">
                    <div class="identity-icon">✨</div>
                    <div class="identity-label">Light Being</div>
                </button>
                <button class="identity-option" data-identity="abstract" data-type="shadow">
                    <div class="identity-icon">🌑</div>
                    <div class="identity-label">Shadow</div>
                </button>
            </div>
            <div class="identity-custom">
                <input type="text" id="customIdentity" placeholder="Or describe yourself..." maxlength="50">
                <button id="customSubmit" class="custom-submit-btn">Be Me</button>
            </div>
        </div>
    </div>


    <!-- AI Vocal Studio Overlay -->
    <div class="vocal-studio-overlay" id="vocalStudioOverlay">
        <div class="studio-container">
            <!-- Header -->
            <div class="vocal-header-bar">
                <div class="vocal-logo-section">
                    <img src="sf-logo.png" alt="SF" class="vocal-sf-logo">
                    <div class="vocal-title">AI VOCAL STUDIO</div>
                </div>
                <div class="vocal-status-indicators">
                    <div class="vocal-indicator">
                        <div class="vocal-indicator-dot active"></div>
                        <span>AUDIO ENGINE</span>
                    </div>
                    <div class="vocal-indicator">
                        <div class="vocal-indicator-dot active"></div>
                        <span>AI PROCESSOR</span>
                    </div>
                    <div class="vocal-indicator">
                        <div class="vocal-indicator-dot" id="vocalRecordIndicator"></div>
                        <span>RECORDING</span>
                    </div>
                </div>
                <button class="vocal-close-btn" id="vocalCloseBtn">×</button>
            </div>

            <!-- Main Content -->
            <div class="vocal-main-content">
                <!-- Recording Panel -->
                <div class="vocal-recording-panel">
                    <!-- Transport -->
                    <div class="vocal-transport">
                        <button class="vocal-record-btn" id="vocalRecordBtn">
                            <div class="vocal-record-dot"></div>
                        </button>
                        <div class="vocal-time-displays">
                            <div class="vocal-time-display">
                                <div class="vocal-time-label">Elapsed</div>
                                <div class="vocal-time-value" id="vocalElapsed">00:00</div>
                            </div>
                            <div class="vocal-time-display">
                                <div class="vocal-time-label">Remaining</div>
                                <div class="vocal-time-value" id="vocalRemaining">05:00</div>
                            </div>
                        </div>
                    </div>

                    <!-- Waveform -->
                    <div class="vocal-waveform-section">
                        <div class="vocal-waveform-container">
                            <canvas id="vocalWaveformCanvas"></canvas>
                            <div class="vocal-waveform-overlay" id="vocalWaveformOverlay">READY</div>
                        </div>
                        
                        <!-- Meters -->
                        <div class="vocal-meters-container">
                            <div class="vocal-meter-group">
                                <div class="vocal-meter-label">INPUT LEVEL</div>
                                <div class="vocal-meter-bar">
                                    <div class="vocal-meter-fill" id="vocalInputMeter"></div>
                                </div>
                            </div>
                            <div class="vocal-meter-group">
                                <div class="vocal-meter-label">AI OUTPUT</div>
                                <div class="vocal-meter-bar">
                                    <div class="vocal-meter-fill" id="vocalOutputMeter"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- AI Panel -->
                <div class="vocal-ai-panel">
                    <div class="vocal-ai-header">
                        <div class="vocal-ai-title">AI PROCESSOR</div>
                        <div class="vocal-ai-status" id="vocalAiStatus">READY</div>
                    </div>

                    <div class="vocal-ai-controls">
                        <!-- Auto-Tune -->
                        <div class="vocal-control-section">
                            <div class="vocal-control-title">AUTO-TUNE</div>
                            <div class="vocal-switch-group">
                                <div class="vocal-switch-item">
                                    <span class="vocal-switch-label">Enable Auto-Tune</span>
                                    <div class="vocal-switch active" onclick="toggleVocalSwitch(this)">
                                        <div class="vocal-switch-handle"></div>
                                    </div>
                                </div>
                                <div class="vocal-switch-item">
                                    <span class="vocal-switch-label">Humanize</span>
                                    <div class="vocal-switch" onclick="toggleVocalSwitch(this)">
                                        <div class="vocal-switch-handle"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Key & BPM -->
                        <div class="vocal-control-section">
                            <div class="vocal-control-title">DETECTED</div>
                            <div class="vocal-key-display">
                                <div class="vocal-key-label">Key</div>
                                <div class="vocal-key-value" id="vocalDetectedKey">A MIN</div>
                                <div class="vocal-bpm-value" id="vocalDetectedBPM">128 BPM</div>
                            </div>
                        </div>

                        <!-- Harmony -->
                        <div class="vocal-control-section">
                            <div class="vocal-control-title">HARMONY GENERATOR</div>
                            <div class="vocal-switch-group">
                                <div class="vocal-switch-item">
                                    <span class="vocal-switch-label">Generate Harmony</span>
                                    <div class="vocal-switch active" onclick="toggleVocalSwitch(this)">
                                        <div class="vocal-switch-handle"></div>
                                    </div>
                                </div>
                                <div class="vocal-switch-item">
                                    <span class="vocal-switch-label">Double Track</span>
                                    <div class="vocal-switch" onclick="toggleVocalSwitch(this)">
                                        <div class="vocal-switch-handle"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

        <!-- Chat component removed -->

    <script>
    // Global app mode: 'find' (browse/hover) or 'drop' (drop pins)
        window.appMode = 'find';
    const TICKET_URL = 'https://soundfactory.ticketspice.com/soundfactory-sance';
    // Ensure any flyer CTA links point to TICKET_URL (HTML contains placeholder hrefs)
    document.addEventListener('DOMContentLoaded', () => {
        try {
            document.querySelectorAll('.floor-flyer a').forEach(a => {
                a.href = TICKET_URL;
                a.target = '_blank';
                a.rel = 'noopener';
            });
        } catch (e) { console.warn('ticket link wiring failed', e); }
    });
    // Replace with real Stripe Checkout link for drinks
    const DRINK_URL = (window.DRINK_URL_OVERRIDE) || 'https://buy.stripe.com/test_abc123';
    // Pin behavior config
    const PIN_TTL_MS = 60000; // 1 minute expiry when owner not nearby
    const PIN_NEAR_RADIUS = 120; // px distance to consider "near" a pin
        window.currentUser = {
            id: null,
            name: null,
            color: '#00ff88',
            hasDroppedPin: false
        };
        // Admin flag (local-only). Enable via ?admin=1 or long-press logo.
        window.sfAdminEnabled = false;
        function setAdminEnabled(val) {
            window.sfAdminEnabled = !!val;
            try { localStorage.setItem('sf_admin', window.sfAdminEnabled ? '1' : '0'); } catch {}
            showNotification(window.sfAdminEnabled ? '🛠️ Admin mode ON' : '🛠️ Admin mode OFF', window.sfAdminEnabled ? '#00ff88' : '#9aa3b2');
            // Show/hide moderation toggle when admin flips
            try {
                ensureModerationToggleExists();
                if (!window.sfAdminEnabled) {
                    setPinModerationMode(false);
                }
            } catch {}
        }

        // Initialize current user identity (anonymous, persisted per browser)
        window.initCurrentUser = function() {
            try {
                const stored = JSON.parse(localStorage.getItem('sf_user') || 'null');
                if (stored && stored.id) {
                    window.currentUser = {...window.currentUser, ...stored};
                } else {
                    const id = `u_${Math.random().toString(36).slice(2,10)}`;
                    const names = ['Alex','Sam','Jordan','Casey','Riley','Taylor','Sky','Kai'];
                    const colors = ['#00ff88','#ff00ff','#00ffff','#ffd700','#ff6b35'];
                    const name = names[Math.floor(Math.random()*names.length)] + ' #' + id.slice(-3).toUpperCase();
                    const color = colors[Math.floor(Math.random()*colors.length)];
                    window.currentUser = { id, name, color, hasDroppedPin: false };
                    localStorage.setItem('sf_user', JSON.stringify(window.currentUser));
                }
                // Persist pin usage flag
                const used = localStorage.getItem('sf_user_pin_used') === '1';
                window.currentUser.hasDroppedPin = used;
                // Colorize my character
                const me = document.getElementById('myCharacter');
                if (me) me.style.setProperty('--color', window.currentUser.color);
                // If we already have a photo, apply it right away
                if (window.currentUser.photo) {
                    applyUserPhoto(window.currentUser.photo);
                }
            } catch(e) { console.warn('initCurrentUser failed', e); }
        }
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize admin from query/localStorage
            try {
                const params = new URLSearchParams(location.search);
                const qAdmin = params.get('admin');
                const storedAdmin = localStorage.getItem('sf_admin') === '1';
                if (qAdmin === '1' || storedAdmin) {
                    window.sfAdminEnabled = true;
                }
            } catch {}
            // Create moderation toggle if admin is enabled
            ensureModerationToggleExists();
            const tabs = document.querySelectorAll('#modeSwitch .mode-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    tabs.forEach(t => { t.classList.remove('active'); t.setAttribute('aria-selected', 'false'); });
                    const btn = e.currentTarget;
                    btn.classList.add('active');
                    btn.setAttribute('aria-selected', 'true');
                    window.appMode = btn.dataset.mode; // 'find' or 'drop'
                    // Small feedback
                    showNotification(window.appMode === 'drop' ? '📍 Drop Pin' : '🔎 Find Friends', '#9fb3ff');
                });
            });
            // Verify button removed from header in this layout

            // Add Photo flow
            const photoInput = document.getElementById('photoInput');
            if (photoInput) {
                photoInput.addEventListener('change', async (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (!file) return;
                    // Limit ~1.5MB and compress to 128x128
                    const imgUrl = await fileToDataURL(file);
                    const resized = await resizeImage(imgUrl, 128, 128, 0.8);
                    try {
                        const stored = JSON.parse(localStorage.getItem('sf_user') || 'null') || {};
                        stored.photo = resized;
                        localStorage.setItem('sf_user', JSON.stringify(stored));
                        window.currentUser = { ...window.currentUser, photo: resized };
                        applyUserPhoto(resized);
                        // Reflect on header account button
                        try { const b = document.getElementById('accountBtn'); if (b) { b.classList.add('has-photo'); b.style.backgroundImage = `url('${resized}')`; } } catch{}
                        showNotification('📸 Photo updated', '#00ff88');
                    } catch(err) { console.warn('Photo save failed', err); }
                });
            }

            // Disable auto photo prompt; user can add photo from overlay or their profile later

            // Account modal wiring
            const acctBtn = document.getElementById('accountBtn');
            const acctModal = document.getElementById('accountModal');
            const acctName = document.getElementById('acctName');
            const acctUpload = document.getElementById('acctUpload');
            const acctVerify = document.getElementById('acctVerify');
            const acctClose = document.getElementById('acctClose');
            const syncAccountBtn = () => {
                try {
                    const u = window.currentUser || {};
                    if (u.photo) {
                        acctBtn.classList.add('has-photo');
                        acctBtn.style.backgroundImage = `url('${u.photo}')`;
                    } else {
                        acctBtn.classList.remove('has-photo');
                        acctBtn.style.backgroundImage = 'none';
                    }
                } catch {}
            };
            acctBtn?.addEventListener('click', () => {
                if (acctName) acctName.value = window.currentUser?.name || '';
                if (acctModal) acctModal.style.display = 'flex';
            });
            acctUpload?.addEventListener('click', () => { document.getElementById('photoInput')?.click(); });
            acctVerify?.addEventListener('click', async () => {
                try {
                    if (typeof window.openSMSModal === 'function') return window.openSMSModal();
                    const phone = prompt('Enter your phone number (e.g. +1234567890)');
                    if (!phone) return;
                    await window.sfSMS?.sendCode(phone);
                    const code = prompt('Enter the code you received');
                    if (!code) return;
                    const result = await window.sfSMS?.verifyCode(phone, code);
                    if (result && (result.token || result.ok)) {
                        const token = result.token || result.ok;
                        document.cookie = 'sf_token=' + token + '; path=/';
                        window.smsGate && (window.smsGate.isVerified = true, window.smsGate.enableFeatures?.());
                        window.dispatchEvent(new CustomEvent('sf:auth', { detail: { token, phone } }));
                        showNotification('✅ Phone verified', '#00ff88');
                        if (acctModal) acctModal.style.display = 'none';
                    } else {
                        showNotification('⚠️ Verification failed', '#ff6b6b');
                    }
                } catch (err) {
                    console.warn('Account verify fallback failed', err);
                    showNotification('⚠️ Could not verify right now', '#ff6b6b');
                }
            });
            acctClose?.addEventListener('click', () => { if (acctModal) acctModal.style.display = 'none'; });
            acctName?.addEventListener('change', () => {
                const val = acctName.value.trim();
                if (!val) return;
                try {
                    const storedRaw = localStorage.getItem('sf_user');
                    let stored = storedRaw ? JSON.parse(storedRaw) : {};
                    stored.name = val;
                    localStorage.setItem('sf_user', JSON.stringify(stored));
                    window.currentUser = { ...window.currentUser, name: val };
                    showNotification('✅ Name updated', '#00ff88');
                } catch {}
            });
            // Initial sync
            setTimeout(syncAccountBtn, 0);

            // Long-press on logo to toggle admin locally
            const logoContainer = document.querySelector('.logo-container');
            if (logoContainer) {
                let pressTimer;
                const start = () => { pressTimer = setTimeout(() => setAdminEnabled(!window.sfAdminEnabled), 1200); };
                const cancel = () => { if (pressTimer) clearTimeout(pressTimer); };
                logoContainer.addEventListener('touchstart', start, { passive: true });
                logoContainer.addEventListener('touchend', cancel);
                logoContainer.addEventListener('mousedown', start);
                logoContainer.addEventListener('mouseup', cancel);
                logoContainer.addEventListener('mouseleave', cancel);
            }

            // Onboarding logic
            const onboardOverlay = document.getElementById('onboardOverlay');
            const params2 = new URLSearchParams(location.search);
            const shouldShowOnboard = params2.get('onboard') === '1';
            // Default to seen so it never pops unless explicitly requested
            if (!localStorage.getItem('sf_onboard_seen')) {
                localStorage.setItem('sf_onboard_seen','1');
            }
            if (shouldShowOnboard) {
                onboardOverlay.style.display = 'flex';
                setTimeout(()=>document.getElementById('onAddPhoto')?.focus(), 0);
            }
            const closeOnboard = () => {
                onboardOverlay.style.display = 'none';
                localStorage.setItem('sf_onboard_seen','1');
            };
            document.getElementById('onSkip')?.addEventListener('click', closeOnboard);
            document.getElementById('onFind')?.addEventListener('click', closeOnboard);
            document.getElementById('onAddPhoto')?.addEventListener('click', () => { photoInput?.click(); });
            document.getElementById('onGoDrop')?.addEventListener('click', () => {
                setAppMode('drop');
                closeOnboard();
            });
            document.getElementById('onVerify')?.addEventListener('click', () => {
                if (window.openSMSModal) window.openSMSModal(); else if (window.smsGate?.redirectToSMSGate) window.smsGate.redirectToSMSGate();
                closeOnboard();
            });
        });

        // Helper to switch tabs programmatically
        function setAppMode(mode) {
            const tabs = document.querySelectorAll('#modeSwitch .mode-tab');
            tabs.forEach(t => {
                const isActive = t.dataset.mode === mode;
                t.classList.toggle('active', isActive);
                t.setAttribute('aria-selected', String(isActive));
            });
            window.appMode = mode;
            showNotification(mode === 'drop' ? '📍 Drop Pin' : '🔎 Find Friends', '#9fb3ff');
        }
        
        // ===== Admin Pin Moderation: visible delete buttons =====
        window.pinModerationMode = false;
        function setPinModerationMode(val) {
            window.pinModerationMode = !!val;
            document.body.classList.toggle('moderation-mode', window.pinModerationMode);
            const btn = document.getElementById('pinModerateToggle');
            if (btn) {
                btn.classList.toggle('active', window.pinModerationMode);
                btn.setAttribute('aria-pressed', String(window.pinModerationMode));
                btn.textContent = window.pinModerationMode ? '✓ Moderating Pins' : 'Moderate Pins';
            }
            // Ask pin system to refresh badges
            try { window.pinSystem?.refreshModerationBadges?.(); } catch {}
        }
        
        function ensureModerationToggleExists() {
            // Inject minimal CSS once
            if (!document.getElementById('moderationStyles')) {
                const st = document.createElement('style');
                st.id = 'moderationStyles';
                st.textContent = `
                #pinModerateToggle{
                    position: fixed; top: 72px; right: 10px; z-index: 4000;
                    background: rgba(20,20,20,0.85); color: #ffd6e8; border: 1px solid #ff4d8a55;
                    border-radius: 999px; padding: 6px 10px; font-size: 12px; cursor: pointer;
                    backdrop-filter: blur(6px); box-shadow: 0 6px 18px rgba(0,0,0,.35);
                }
                #pinModerateToggle.active{ background: rgba(0,255,136,0.18); color:#afffda; border-color:#00ff8855; }
                .enhanced-pin{ position: absolute; }
                .pin-delete-badge{
                    position: absolute; top: -8px; right: -8px; width: 18px; height: 18px; line-height: 16px;
                    border-radius: 50%; background: #ff4d4d; color: white; border: 1px solid #0008;
                    font-size: 12px; font-weight: 700; text-align: center; cursor: pointer; pointer-events: auto;
                    transform: rotate(45deg); /* counter parent rotation for readability */
                    box-shadow: 0 2px 8px rgba(0,0,0,.35);
                }
                body:not(.moderation-mode) .pin-delete-badge{ display: none !important; }
                `;
                document.head.appendChild(st);
            }

            // Ensure toggle button exists and matches admin state
            let btn = document.getElementById('pinModerateToggle');
            if (!btn) {
                btn = document.createElement('button');
                btn.id = 'pinModerateToggle';
                btn.type = 'button';
                btn.setAttribute('aria-label', 'Toggle pin moderation');
                btn.setAttribute('aria-pressed', 'false');
                btn.textContent = 'Moderate Pins';
                btn.addEventListener('click', () => setPinModerationMode(!window.pinModerationMode));
                document.body.appendChild(btn);
            }
            btn.style.display = window.sfAdminEnabled ? 'block' : 'none';
        }

        // Utilities for photo handling
        async function fileToDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        async function resizeImage(dataUrl, maxW, maxH, quality = 0.85) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    let { width, height } = img;
                    const scale = Math.min(maxW/width, maxH/height, 1);
                    width = Math.round(width * scale);
                    height = Math.round(height * scale);
                    canvas.width = width; canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', quality));
                };
                img.src = dataUrl;
            });
        }
        function applyUserPhoto(dataUrl) {
            try {
                // Show as avatar circle in the floating profile card if it's "me"
                const pcAvatar = document.getElementById('pcAvatar');
                if (pcAvatar && dataUrl) {
                    pcAvatar.style.backgroundImage = `url('${dataUrl}')`;
                    pcAvatar.style.backgroundSize = 'cover';
                    pcAvatar.style.backgroundPosition = 'center';
                    pcAvatar.textContent = '';
                }
                // Also add a tiny image on my character if there's an element for it
                const me = document.getElementById('myCharacter');
                if (me) {
                    let img = me.querySelector('.char-photo');
                    if (!img) {
                        img = document.createElement('div');
                        img.className = 'char-photo';
                        img.style.cssText = 'position:absolute; bottom:22px; left:22px; width:16px; height:16px; border-radius:50%; overflow:hidden; border:1px solid #0008; box-shadow:0 0 4px #0008; background-size:cover; background-position:center;';
                        me.appendChild(img);
                    }
                    img.style.backgroundImage = `url('${dataUrl}')`;
                }
            } catch(e) { /* no-op */ }
        }
        // Floating profile card element (created once)
        const profileCard = document.createElement('div');
        profileCard.id = 'profileCard';
        profileCard.className = 'profile-card';
        profileCard.innerHTML = `
            <div class="profile-header">
                <div class="profile-avatar" id="pcAvatar">A</div>
                <div>
                    <div class="profile-name" id="pcName">User</div>
                    <div class="profile-sub" id="pcSub">On this floor</div>
                </div>
            </div>
            <div class="profile-actions">
                <button class="profile-btn" id="pcShare">🔗 Share</button>
                <button class="profile-btn" id="pcLike">❤ Like</button>
                <button class="profile-btn" id="pcComment">💬 Comment</button>
                <button class="profile-btn" id="pcDrink">🍹 Drink</button>
                <button class="profile-btn" id="pcTicket">🎫 Ticket</button>
            </div>
        `;
        document.body.appendChild(profileCard);
        // SMS Verification Gate System
        class SMSVerificationGate {
            constructor() {
                this.isVerified = false;
                this.smsGateUrl = (window.SMS_API_BASE || 'https://sf-sms-service.netlify.app') + '/';
                this.init();
            }
            
            init() {
                this.checkVerificationStatus();
            }
            
            checkVerificationStatus() {
                // TEMPORARY BYPASS FOR TESTING - Remove when SMS is fixed
                const urlParams = new URLSearchParams(window.location.search);
                const bypassMode = urlParams.get('bypass') === 'true' || localStorage.getItem('sf_bypass') === 'true';
                
                if (bypassMode) {
                    console.log('🚀 BYPASS MODE ACTIVE - SMS verification skipped');
                    this.isVerified = true;
                    this.enableFeatures();
                    // Show a small dev notice once
                    if (!localStorage.getItem('sf_bypass_notice')) {
                        showNotification('Dev bypass: SMS disabled locally', '#9fb3ff');
                        localStorage.setItem('sf_bypass_notice','1');
                    }
                    return;
                }
                
                // Check for sf_token cookie
                const token = this.getCookie('sf_token');
                
                if (token && token !== '') {
                    this.isVerified = true;
                    this.enableFeatures();
                } else {
                    this.showVerificationGate();
                }
            }
            
            getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
                return null;
            }
            
            showVerificationGate() {
                // Prefer opening SMS modal immediately
                if (window.openSMSModal) {
                    window.openSMSModal();
                    return;
                }
                // Fallback: small banner if SDK isn't ready yet
                if (!document.getElementById('smsVerificationBanner')) {
                    const banner = document.createElement('div');
                    banner.id = 'smsVerificationBanner';
                    banner.style.cssText = `
                        position: fixed; top: 8px; left: 50%; transform: translateX(-50%);
                        background: rgba(255, 26, 120, 0.15); color: #ffd6e8;
                        border: 1px solid rgba(255, 26, 120, 0.5); border-radius: 999px;
                        padding: 6px 10px; z-index: 5000; font-size: 12px; display: flex; gap: 8px; align-items: center;
                        backdrop-filter: blur(6px);
                    `;
                    banner.innerHTML = `
                        <span>🔐 Verify phone to unlock all features</span>
                        <button id="smsVerifyBtnInline" style="background:#ff1a78; color:white; border:none; border-radius:999px; padding:4px 10px; font-size:12px; cursor:pointer;">Verify</button>
                        <button id="smsHideBanner" style="background:transparent; color:#ffd6e8; border:none; padding:4px 6px; cursor:pointer;">Hide</button>
                    `;
                    document.body.appendChild(banner);
                    const open = async () => {
                        if (window.openSMSModal) return window.openSMSModal();
                        // Fallback: prompt for phone and send code via API
                        try {
                            const phone = prompt('Enter your phone number (e.g. +1234567890)');
                            if (!phone) return;
                            await window.sfSMS?.sendCode(phone);
                            const code = prompt('Enter the code you received');
                            if (!code) return;
                            const result = await window.sfSMS?.verifyCode(phone, code);
                            if (result && (result.token || result.ok)) {
                                const token = result.token || result.ok;
                                document.cookie = 'sf_token=' + token + '; path=/';
                                this.isVerified = true; this.enableFeatures();
                                window.dispatchEvent(new CustomEvent('sf:auth', { detail: { token, phone } }));
                                showNotification('✅ Phone verified', '#00ff88');
                                return;
                            }
                            showNotification('⚠️ Verification failed', '#ff6b6b');
                        } catch (err) {
                            console.warn('Inline verify failed', err);
                            window.location.href = this.smsGateUrl;
                        }
                    };
                    document.getElementById('smsVerifyBtnInline').addEventListener('click', open);
                    document.getElementById('smsHideBanner').addEventListener('click', () => banner.remove());
                }
            }
            
            redirectToSMSGate() {
                // Store current page for return redirect
                sessionStorage.setItem('sf_return_url', window.location.href);
                
                // Redirect to SMS verification
                window.location.href = this.smsGateUrl;
            }
            
            enableFeatures() {
                // Remove banner if exists
                const overlay = document.getElementById('smsVerificationOverlay');
                if (overlay) overlay.remove();
                const banner = document.getElementById('smsVerificationBanner');
                if (banner) banner.remove();
                
                // Enable all interactive buttons
                const buttons = document.querySelectorAll('.vocal-studio-btn, .alams-btn, .social-btn');
                buttons.forEach(btn => {
                    btn.style.pointerEvents = 'auto';
                    btn.style.opacity = '1';
                });

                // Initialize current user identity and styling
                if (typeof window.initCurrentUser === 'function') {
                    window.initCurrentUser();
                }
                
                // Show welcome notification
                setTimeout(() => {
                    showNotification('🎉 Welcome to Sound Factory NYC!', '#00ff88');
                }, 1000);
            }
            
            disableFeatures() {
                // Soft gate: keep site interactive; individual features will check smsGate.isVerified themselves
            }
            
            // Check verification status periodically (in case user verifies in another tab)
            startVerificationCheck() {
                setInterval(() => {
                    if (!this.isVerified) {
                        this.checkVerificationStatus();
                    }
                }, 5000); // Check every 5 seconds
            }
        }

        // Floor Navigation System from blueprints.html
        class FloorNavigationSystem {
            constructor() {
                this.floorButtons = document.querySelectorAll('.floor-btn');
                this.floors = document.querySelectorAll('.floor');
                this.currentFloor = 'mf'; // Default to main floor
                
                // Floor mapping
                this.floorMap = {
                    'b': 'floor-b',
                    'mf': 'floor-mf',
                    'mz': 'floor-mz',
                    '2': 'floor-2',
                    '3': 'floor-3'
                };
                this.floorNames = {
                    'b': 'Basement',
                    'mf': 'Main Floor',
                    'mz': 'Mezzanine',
                    '2': 'Second Floor',
                    '3': 'Third Floor'
                };
                this.hudEl = null;
                
                this.init();
            }
            
            init() {
                // Add click event to each button
                this.floorButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        // Remove active class from all buttons
                        this.floorButtons.forEach(btn => btn.classList.remove('active'));
                        
                        // Add active class to clicked button
                        e.currentTarget.classList.add('active');
                        
                        // Get the floor to show
                        const floorToShow = e.currentTarget.getAttribute('data-floor');
                        this.currentFloor = floorToShow;
                        const floorId = this.floorMap[floorToShow];
                        
                        // Hide all floors
                        this.floors.forEach(floor => floor.classList.remove('active'));
                        
                        // Show selected floor
                        const selectedFloor = document.getElementById(floorId);
                        if (selectedFloor) {
                            selectedFloor.classList.add('active');
                        }
                        // Subtle flash on floor change
                        document.body.classList.add('floor-flash');
                        setTimeout(()=>document.body.classList.remove('floor-flash'), 420);
                        
                        // Update character visibility based on floor
                        if (window.socialFloor) {
                            window.socialFloor.updateCharacterVisibility(floorToShow);
                        }
                    });
                });
                
                // Touch event handling for better mobile experience
                let touchStartY = 0;
                let touchEndY = 0;
                
                document.addEventListener('touchstart', (e) => {
                    touchStartY = e.changedTouches[0].screenY;
                }, false);
                
                document.addEventListener('touchend', (e) => {
                    touchEndY = e.changedTouches[0].screenY;
                    this.handleSwipe();
                }, false);
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    const activeButton = document.querySelector('.floor-btn.active');
                    let nextButton = null;
                    
                    if (e.key === 'ArrowUp') {
                        nextButton = activeButton.previousElementSibling;
                    } else if (e.key === 'ArrowDown') {
                        nextButton = activeButton.nextElementSibling;
                    }
                    
                    if (nextButton && nextButton.classList.contains('floor-btn')) {
                        nextButton.click();
                    }
                });
                
                // Prevent pinch zoom on iOS
                document.addEventListener('gesturestart', (e) => {
                    e.preventDefault();
                });
            }
            
            handleSwipe() {
                const activeButton = document.querySelector('.floor-btn.active');
                let nextButton = null;
                
                if (touchEndY < touchStartY - 50) {
                    // Swiped up
                    nextButton = activeButton?.previousElementSibling;
                    // Wrap-around to last if none
                    if (!nextButton || !nextButton.classList?.contains('floor-btn')) {
                        const all = Array.from(this.floorButtons);
                        nextButton = all[all.length - 1] || null;
                    }
                }
                
                if (touchEndY > touchStartY + 50) {
                    // Swiped down
                    nextButton = activeButton?.nextElementSibling;
                    // Wrap-around to first if none
                    if (!nextButton || !nextButton.classList?.contains('floor-btn')) {
                        const all = Array.from(this.floorButtons);
                        nextButton = all[0] || null;
                    }
                }
                
                if (nextButton && nextButton.classList.contains('floor-btn')) {
                    nextButton.click();
                    // Show HUD indicator on floor change
                    const code = nextButton.getAttribute('data-floor');
                    this.showFloorHUD(this.floorNames[code] || code.toUpperCase());
                }
            }
            
            getCurrentFloor() {
                return this.currentFloor;
            }

            ensureHUD() {
                if (this.hudEl) return this.hudEl;
                const el = document.createElement('div');
                el.id = 'floorHUD';
                el.style.cssText = `
                    position: fixed; left: 50%; top: 64px; transform: translateX(-50%);
                    background: rgba(20,20,20,0.9); border: 1px solid rgba(255,255,255,0.08);
                    color: #fff; padding: 6px 12px; border-radius: 999px; z-index: 4000;
                    font-size: 12px; letter-spacing: 0.02em; backdrop-filter: blur(6px);
                    box-shadow: 0 8px 24px rgba(0,0,0,.35); opacity: 0; transition: opacity .2s ease; pointer-events:none;
                `;
                document.body.appendChild(el);
                this.hudEl = el;
                return el;
            }

            showFloorHUD(text) {
                const el = this.ensureHUD();
                el.textContent = text;
                el.style.opacity = '1';
                clearTimeout(this._hudTimer);
                this._hudTimer = setTimeout(() => { el.style.opacity = '0'; }, 900);
            }
        }

        // Social Floor System from jpins.html
        class SocialFloor {
            constructor() {
                this.myCharacter = document.getElementById('myCharacter');
                this.x = window.innerWidth / 2;
                this.y = window.innerHeight / 2;
                this.targetX = this.x;
                this.targetY = this.y;
                this.walkStyle = 'normal';
                this.others = [];
                this.nearbyPeople = [];
                this.closestPerson = null;
                this.cardPinned = false;
                this.cardHoverTs = 0;
                this.cardGraceMs = 450; // small grace so it doesn’t vanish immediately
                this.messages = [];
                this.currentFloor = 'mf'; // Default to main floor
                // Manual hover override when user points at a specific character
                this.hoverOverride = null;
                // Expose last known position for other systems (e.g., pins)
                window.sfUserPosition = { x: this.x, y: this.y, floor: this.currentFloor, ts: Date.now() };
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.generateOthers();
                // Set initial background class
                // Floor background is now part of each floor's SVG blueprint
                this.animate();
            }

            setupEventListeners() {

                // Group chat removed

                // Close profile card if tap outside on mobile with grace
                document.addEventListener('click', (e) => {
                    const card = document.getElementById('profileCard');
                    if (!card) return;
                    const clickedCharacter = e.target.closest('.character');
                    const clickedCard = e.target.closest('#profileCard');
                    if (clickedCard) {
                        // Pin the card on any click inside so users can interact
                        this.cardPinned = true;
                        this.cardHoverTs = Date.now();
                        return;
                    }
                    if (!clickedCard && !clickedCharacter) this.hideHoverCard();
                });

                // Keep card alive when hovering it (desktop)
                const pc = document.getElementById('profileCard');
                if (pc) {
                    pc.addEventListener('mouseenter', () => { this.cardHoverTs = Date.now(); this.cardPinned = true; });
                    pc.addEventListener('mouseleave', () => { this.cardHoverTs = Date.now(); setTimeout(()=>{ this.cardPinned = false; }, this.cardGraceMs); });
                }

                // Tap/click on my own character to show my signed-in name and photo
                if (this.myCharacter) {
                    const openSelf = () => {
                        if (window.appMode !== 'find') return;
                        this.showHoverCard(this.getSelfPerson());
                    };
                    this.myCharacter.addEventListener('click', openSelf);
                    this.myCharacter.addEventListener('touchend', openSelf);
                }

                // Swipe across floor to quick-like/share (groundwork)
                let swipeStartX = null;
                document.addEventListener('touchstart', (e) => { swipeStartX = e.touches[0].clientX; }, { passive:true });
                document.addEventListener('touchend', (e) => {
                    if (swipeStartX == null) return;
                    const dx = e.changedTouches[0].clientX - swipeStartX;
                    swipeStartX = null;
                    if (Math.abs(dx) > 60 && window.appMode === 'find') {
                        const dir = dx > 0 ? 'right' : 'left';
                        this.handleFloorSwipe(dir);
                    }
                });
            }

            getSelfPerson() {
                return {
                    isSelf: true,
                    name: (window.currentUser && window.currentUser.name) ? window.currentUser.name : 'You',
                    photo: window.currentUser && window.currentUser.photo ? window.currentUser.photo : null,
                    x: this.x,
                    y: this.y,
                    element: this.myCharacter,
                    floor: this.currentFloor
                };
            }

            generateOthers() {
                const colors = ['#ff00ff', '#00ffff', '#ffd700', '#ff6b35'];
                const names = ['Alex', 'Sam', 'Jordan', 'Casey', 'Riley'];
                const floors = ['b', 'mf', 'mz', '2', '3'];

                // Ensure pin system is ready
                window.pinSystem?.ensureInitialized?.();

                for (let i = 0; i < 12; i++) {
                    const floor = floors[i % floors.length];
                    const color = colors[i % colors.length];
                    const name = names[i % names.length];
                    // random percent positions inside viewport
                    const xPct = 10 + Math.random() * 80;
                    const yPct = 15 + Math.random() * 70;

                    // Create a static pin representing this person
                    const pin = window.pinSystem?.addExternalPin?.({
                        x: xPct,
                        y: yPct,
                        color,
                        type: 'moment',
                        ownerName: name,
                        ownerPhoto: '',
                        floor
                    });

                    // Track minimal data to keep counts by floor and proximity
                    this.others.push({ element: pin, name, floor, xPct, yPct });
                }
                this.updatePeopleCount();
            }

            update() {
                // Character stays in place - no movement controls
                if (this.myCharacter) this.myCharacter.style.transform = 'translate(-12px, -12px)';
                // Clamp to viewport
                const padX = 12, padTop = 80, padBot = 24;
                this.x = Math.min(Math.max(this.x, padX), window.innerWidth - padX);
                this.y = Math.min(Math.max(this.y, padTop), window.innerHeight - padBot);
                
                this.myCharacter.style.left = `${this.x}px`;
                this.myCharacter.style.top = `${this.y}px`;
                // Update global position for other systems
                window.sfUserPosition = { x: this.x, y: this.y, floor: this.currentFloor, ts: Date.now() };
                
                // Check if moving
                if (moving) {
                    this.myCharacter.classList.add('walking');
                } else {
                    this.myCharacter.classList.remove('walking');
                }
                // Others are static pins now; no per-frame position updates needed
                
                // Check proximity
                this.checkProximity();
            }

            checkProximity() {
                // Proximity hover against static pins on current floor
                this.nearbyPeople = [];

                // If in Drop mode or interacting with pins, hide people UI
                if (window.appMode === 'drop' || window.sfPinPopupOpen || window.sfOverPin) {
                    this.hideHoverCard();
                    this.myCharacter.classList.remove('near-others');
                    return;
                }

                // Determine closest pin (other) on current floor within radius
                const pinCanvas = document.getElementById('pin-canvas');
                const rect = pinCanvas ? pinCanvas.getBoundingClientRect() : null;
                let closest = null;
                let closestDist = Infinity;
                const radius = 80; // px
                if (rect) {
                    this.others.forEach(other => {
                        if (other.floor !== this.currentFloor || !other.element) return;
                        const ox = (other.xPct / 100) * rect.width + rect.left;
                        const oy = (other.yPct / 100) * rect.height + rect.top;
                        const dx = ox - this.x;
                        const dy = oy - this.y;
                        const d = Math.hypot(dx, dy);
                        if (d < radius) {
                            // Prefer live owner fields from the pin dataset to avoid mismatches
                            const ds = other.element?.dataset || {};
                            const name = ds.ownerName || other.name;
                            const photo = ds.ownerPhoto || null;
                            const enriched = { ...other, name, x: ox, y: oy, isLive: true, photo };
                            this.nearbyPeople.push(enriched);
                            if (d < closestDist) { closestDist = d; closest = enriched; }
                        }
                    });
                }

                if (this.hoverOverride) {
                    this.myCharacter.classList.add('near-others');
                    this.showHoverCard(this.hoverOverride);
                    return;
                }
                if (closest) {
                    this.myCharacter.classList.add('near-others');
                    this.showHoverCard(closest);
                } else {
                    if (!this.cardPinned) this.hideHoverCard();
                    this.myCharacter.classList.remove('near-others');
                }
            }

            sendMessage(text) {
                // Show message bubble
                const bubble = document.getElementById('myChatBubble');
                bubble.textContent = text;
                bubble.classList.add('show');
                
                setTimeout(() => {
                    bubble.classList.remove('show');
                }, 3000);
                
                // Group chat removed
                
                // Simulate responses
                if (this.nearbyPeople.length > 0 && Math.random() > 0.5) {
                    setTimeout(() => {
                        const responses = ['Hey!', 'Vibes!', '🔥', 'Love it!', 'Same!'];
                        const person = this.nearbyPeople[0];
                        const response = responses[Math.floor(Math.random() * responses.length)];
                        // Group chat removed
                        
                        // Show their bubble
                        const theirBubble = person.element.querySelector('.chat-bubble');
                        theirBubble.textContent = response;
                        theirBubble.classList.add('show');
                        
                        setTimeout(() => {
                            theirBubble.classList.remove('show');
                        }, 3000);
                    }, 1000);
                }
            }

            // addChatMessage and renderGroupParticipants removed

            showHoverCard(person) {
                if (window.appMode !== 'find') return; // suppress in drop mode
                this.closestPerson = person;
                const card = document.getElementById('profileCard');
                if (!card) return;
                // Fill content
                const initials = (person.name || '').slice(0,1).toUpperCase();
                const pcA = document.getElementById('pcAvatar');
                if (person.photo) {
                    pcA.style.backgroundImage = `url('${person.photo}')`;
                    pcA.style.backgroundSize = 'cover';
                    pcA.style.backgroundPosition = 'center';
                    pcA.style.backgroundRepeat = 'no-repeat';
                    pcA.style.backgroundColor = 'transparent';
                    pcA.textContent = '';
                } else {
                    // Unique monogram tile per person
                    const base = person.avatarColor || person.color || '#9bbcff';
                    pcA.style.backgroundImage = 'none';
                    pcA.style.background = `radial-gradient(circle at 30% 30%, rgba(255,255,255,0.85), ${base})`;
                    pcA.style.backgroundSize = 'auto';
                    pcA.style.backgroundPosition = 'center';
                    pcA.style.backgroundRepeat = 'no-repeat';
                    pcA.textContent = initials || '•';
                }
                // If this is "me", override with my signed-in info
                const isMe = person.isSelf === true;
                const displayName = isMe && window.currentUser?.name ? window.currentUser.name : (person.name || 'Guest');
                document.getElementById('pcName').textContent = displayName;
                const sub = isMe ? 'You' : (person.isLive === false ? 'Offline' : 'Live nearby');
                const subEl = document.getElementById('pcSub');
                subEl.textContent = sub;
                subEl.className = (person.isLive === false) ? 'profile-sub offline' : 'profile-sub';
                
                // Position near the person (clamped to viewport)
                const x = person.x + 20;
                const y = person.y - 20;
                const pad = 10;
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const cardW = 160; // tighter clamp for tiny card
                const cardH = 110;
                card.style.left = Math.min(Math.max(x, pad), vw - cardW - pad) + 'px';
                card.style.top = Math.min(Math.max(y, pad), vh - cardH - pad) + 'px';
                card.style.display = 'block';
                this.cardHoverTs = Date.now();
            }

            hideHoverCard() {
                if (this.cardPinned) {
                    // If pinned, only hide if grace period passed and far away
                    const since = Date.now() - this.cardHoverTs;
                    if (since < this.cardGraceMs) return;
                }
                const card = document.getElementById('profileCard');
                if (card) card.style.display = 'none';
                this.closestPerson = null;
                this.cardPinned = false;
            }

            updatePeopleCount() {
                // Count people on current floor only
                const peopleOnCurrentFloor = this.others.filter(other => other.floor === this.currentFloor).length + 1;
                document.getElementById('peopleCount').textContent = peopleOnCurrentFloor;
            }

            updateCharacterVisibility(floor) {
                this.currentFloor = floor;
                if (window.sfUserPosition) window.sfUserPosition.floor = floor;
                // Background is tied to each floor's inline SVG; no sync needed
                
                // Update visibility of others (now pins) based on floor
                this.others.forEach(other => {
                    if (!other?.element) return;
                    other.element.style.display = (other.floor === floor) ? 'block' : 'none';
                });
                
                // Update people count for the current floor
                this.updatePeopleCount();
                
                // Reset nearby people
                this.nearbyPeople = [];
                this.myCharacter.classList.remove('near-others');
                this.hideHoverCard();

                // Subtle visual flash to confirm floor change
                try {
                    document.body.classList.add('floor-flash');
                    clearTimeout(this._flashTimer);
                    this._flashTimer = setTimeout(()=>document.body.classList.remove('floor-flash'), 420);
                } catch {}
            }

            // Removed syncFloorBackground (SVG floor blueprints handle visuals)

            animate() {
                this.update();
                requestAnimationFrame(() => this.animate());
            }
            handleFloorSwipe(direction) {
                // Quick actions on swipe: right = Like closest, left = Share closest
                // Find the closest in nearby list (<80) else the last targeted
                const target = (this.nearbyPeople && this.nearbyPeople[0]) || this.closestPerson;
                if (!target) return;
                // Visual feedback: small toast
                if (direction === 'right') {
                    showNotification(`❤️ Liked ${target.name}`, '#00ff88');
                } else {
                    if (navigator.share) {
                        navigator.share({ title: 'Sound Factory', text: `Hanging near ${target.name}`, url: location.href }).catch(()=>{});
                    } else {
                        showNotification('📤 Share copied', '#9fb3ff');
                        try{ navigator.clipboard.writeText(location.href); }catch{}
                    }
                }
            }
        }

        // Enhanced Pin System from blueprints.html
        class EnhancedPinSystem {
            constructor() {
                this.pinSystemActivated = false;
                this.currentPosition = { x: 0, y: 0 };
                this.activeAnimations = new Set();
                this.pinContainer = null;
                this.pinCanvas = null;
                this.selector = null;
                this.userPins = new Map(); // userId -> element
                this.pinMeta = new WeakMap(); // pin -> { createdAt, lastSeenTs, floor }
                
                // Enhanced pin configuration
                this.ENHANCED_CONFIG = {
                    pinTypes: {
                        memory: { color: '#0066ff', emoji: '📸', max: null },
                        song: { color: '#ffcc00', emoji: '🎵', max: null },
                        moment: { color: '#ff0066', emoji: '🔥', max: 1 },
                        dream: { color: '#00ff88', emoji: '💭', max: null },
                        promo: { color: '#9933ff', emoji: '🎉', hostOnly: true }
                    },
                    maxPinsPerUser: 5,
                    animations: {
                        maxBlinkers: 3,
                        pulseInterval: 2000,
                        flickerDuration: 45000
                    }
                };
                
                this.init();
            }

            // Allow external callers to ensure the overlay is present
            ensureInitialized() {
                if (!this.pinSystemActivated) {
                    this.pinSystemActivated = true;
                    this.initializeEnhancedPinSystem();
                }
            }
            
            init() {
                // Only activate pin system on first click
                document.addEventListener('click', (e) => {
                    // Respect app mode: only in 'drop' mode we handle clicks for pins
                    if (window.appMode !== 'drop') return;
                    // Skip if clicking on nav buttons or controls
                    if (e.target.closest('.nav-panel') || e.target.closest('.floor-btn') ||
                        e.target.closest('.controls')) return;
                    
                    if (!this.pinSystemActivated) {
                        this.pinSystemActivated = true;
                        this.initializeEnhancedPinSystem();
                    }
                });
            }
            
            initializeEnhancedPinSystem() {
                // Create pin overlay container
                this.pinContainer = document.createElement('div');
                this.pinContainer.id = 'enhanced-pin-system';
                this.pinContainer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 100;
                `;
                document.body.appendChild(this.pinContainer);
                
                // Create pin canvas
                this.pinCanvas = document.createElement('div');
                this.pinCanvas.id = 'pin-canvas';
                this.pinCanvas.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: auto;
                `;
                this.pinContainer.appendChild(this.pinCanvas);
                // Track when the pointer is over the pin layer
                window.sfOverPin = false;
                this.pinCanvas.addEventListener('mouseenter', () => { window.sfOverPin = true; });
                this.pinCanvas.addEventListener('mouseleave', () => { window.sfOverPin = false; });
                
                // Create pin selector UI
                this.selector = document.createElement('div');
                this.selector.id = 'pin-selector';
                this.selector.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%) scale(0);
                    background: rgba(20, 20, 20, 0.95);
                    backdrop-filter: blur(10px);
                    border-radius: 25px;
                    padding: 10px;
                    display: flex;
                    gap: 8px;
                    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    z-index: 200;
                `;
                
                Object.entries(this.ENHANCED_CONFIG.pinTypes).forEach(([type, config]) => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `
                        width: 50px;
                        height: 50px;
                        border-radius: 15px;
                        border: 2px solid ${config.color};
                        background: ${config.color}22;
                        color: white;
                        font-size: 24px;
                        cursor: pointer;
                        transition: all 0.2s;
                    `;
                    btn.innerHTML = config.emoji;
                    btn.onclick = () => this.createPin(type, config);
                    this.selector.appendChild(btn);
                });
                this.pinContainer.appendChild(this.selector);
                
                // Pin creation on click
                this.pinCanvas.addEventListener('click', (e) => {
                    if (window.appMode !== 'drop') return;
                    if (!window.smsGate?.isVerified) {
                        showNotification('🔒 Verify your phone to drop a pin', '#ff6b6b');
                        return;
                    }
                    if (window.currentUser?.hasDroppedPin) {
                        showNotification('📍 You already dropped your pin', '#ffcc00');
                        return;
                    }
                    if (e.target === this.pinCanvas) {
                        const rect = this.pinCanvas.getBoundingClientRect();
                        // Constrain within blueprint (exclude header height already handled by layout)
                        let px = e.clientX - rect.left;
                        let py = e.clientY - rect.top;
                        px = Math.max(0, Math.min(px, rect.width));
                        py = Math.max(0, Math.min(py, rect.height));
                        const x = (px / rect.width) * 100;
                        const y = (py / rect.height) * 100;
                        this.showPinSelector(x, y);
                    }
                });
                
                // Add animations
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes dropIn {
                        from { transform: rotate(-45deg) translate(-50%, -150%) scale(0); opacity: 0; }
                        to { transform: rotate(-45deg) translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                    @keyframes pulse {
                        0%, 100% { box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
                        50% { box-shadow: 0 0 20px currentColor; }
                    }
                    @keyframes flicker {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.5; }
                    }
                    @keyframes glow {
                        from { opacity: 0; transform: scale(0); }
                        50% { opacity: 1; }
                        to { opacity: 0; transform: scale(2); }
                    }
                    @keyframes sparkle {
                        to { transform: translateY(-20px) rotate(180deg); opacity: 0; }
                    }
                    @keyframes floatUp {
                        to { transform: translateY(-40px); opacity: 0; }
                    }
                    @keyframes slideUp {
                        from { transform: translateX(-50%) translateY(20px); opacity: 0; }
                        to { transform: translateX(-50%) translateY(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
                
                console.log('Enhanced Pin System Activated!');
            }

            // Create a pin not tied to the current user (used for static NPC replacements)
            addExternalPin({ x, y, color, type = 'moment', ownerName = 'Guest', ownerPhoto = '', floor = 'mf' }) {
                this.ensureInitialized();
                const pin = document.createElement('div');
                pin.className = 'enhanced-pin';
                pin.style.cssText = `
                    position: absolute;
                    left: ${x}%;
                    top: ${y}%;
                    width: 10px; height: 10px;
                    border-radius: 50% 50% 50% 0;
                    background: ${color};
                    transform: rotate(-45deg) translate(-50%, -50%);
                    cursor: pointer;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    animation: dropIn 0.5s ease;
                `;
                // Persist percent coordinates for proximity math
                pin.dataset.xPct = String(x);
                pin.dataset.yPct = String(y);
                pin.dataset.userId = `ext-${Math.random().toString(36).slice(2,8)}`;
                pin.dataset.ownerName = ownerName;
                pin.dataset.ownerPhoto = ownerPhoto;
                pin.title = `${ownerName} • ${type}`;
                pin.classList.add('dimmed');
                // Tag as external so TTL logic won't delete owner's single pin state
                pin.dataset.external = '1';

                this.applyPinAnimation(pin, type, { color });
                this.pinCanvas.appendChild(pin);
                this.setupPinInteractions(pin, type, { color });
                if (window.sfAdminEnabled) this.attachModerationBadge(pin);
                this.pinMeta.set(pin, { createdAt: Date.now(), lastSeenTs: Date.now(), floor });
                return pin;
            }
            
            showPinSelector(x, y) {
                this.currentPosition = { x, y };
                this.selector.style.transform = 'translateX(-50%) scale(1)';
                setTimeout(() => {
                    this.selector.style.transform = 'translateX(-50%) scale(0)';
                }, 5000);
            }
            
            createPin(type, config) {
                // Enforce one pin per user
                if (!window.currentUser || window.currentUser.hasDroppedPin) {
                    showNotification('📍 Only one pin per user', '#ffcc00');
                    return;
                }
                const pin = document.createElement('div');
                pin.className = 'enhanced-pin';
                pin.style.cssText = `
                    position: absolute;
                    left: ${this.currentPosition.x}%;
                    top: ${this.currentPosition.y}%;
                    width: 15px;
                    height: 15px;
                    border-radius: 50% 50% 50% 0;
                    background: ${config.color};
                    transform: rotate(-45deg) translate(-50%, -50%);
                    cursor: pointer;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    animation: dropIn 0.5s ease;
                `;
                pin.dataset.userId = window.currentUser.id;
                // Store owner metadata for popup rendering
                pin.dataset.ownerName = window.currentUser.name || 'You';
                pin.dataset.ownerPhoto = window.currentUser.photo || '';
                pin.title = `${window.currentUser.name} • ${type}`;
                // Default state: dimmed until you're near it
                pin.classList.add('dimmed');
                
                // Add animation based on type
                this.applyPinAnimation(pin, type, config);
                
                this.pinCanvas.appendChild(pin);
                this.selector.style.transform = 'translateX(-50%) scale(0)';
                
                // Setup interactions
                this.setupPinInteractions(pin, type, config);
                // Attach moderation delete badge if needed
                this.attachModerationBadge(pin);

                // Track meta for expiry
                const floor = window.floorNavigation?.getCurrentFloor?.() || 'mf';
                this.pinMeta.set(pin, { createdAt: Date.now(), lastSeenTs: Date.now(), floor });
                this.userPins.set(window.currentUser.id, pin);

                // Mark user as used
                window.currentUser.hasDroppedPin = true;
                try { localStorage.setItem('sf_user_pin_used', '1'); } catch{}
                showNotification('✅ Pin dropped', '#00ff88');
                
                // Broadcast pin to other users via WebSocket
                if (window.soundFactoryWS && window.soundFactoryWS.isConnected()) {
                    const pinData = {
                        x: this.currentPosition.x,
                        y: this.currentPosition.y,
                        message: type,
                        color: config.color,
                        type: type,
                        userId: window.currentUser.id,
                        userName: window.currentUser.name || 'Anonymous'
                    };
                    window.soundFactoryWS.createPin(pinData);
                    console.log('📡 Pin broadcasted to other users');
                } else {
                    console.warn('⚠️ WebSocket not connected, pin not shared');
                }
            }
            
            applyPinAnimation(pin, type, config) {
                switch(type) {
                    case 'moment':
                        // Red pulse
                        if (this.activeAnimations.size < this.ENHANCED_CONFIG.animations.maxBlinkers) {
                            pin.style.animation += ', pulse 2s infinite';
                            this.activeAnimations.add(pin);
                        }
                        break;
                    case 'song':
                        // Yellow flicker
                        pin.style.animation += ', flicker 1s ease 3';
                        setTimeout(() => {
                            pin.style.animation = pin.style.animation.replace(', flicker 1s ease 3', '');
                        }, 3000);
                        break;
                    case 'memory':
                        // Blue glow
                        break;
                    case 'promo':
                        // Sparkles
                        for(let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                const sparkle = document.createElement('span');
                                sparkle.textContent = '✨';
                                sparkle.style.cssText = `
                                    position: absolute;
                                    font-size: 10px;
                                    animation: sparkle 1s ease forwards;
                                    pointer-events: none;
                                `;
                                pin.appendChild(sparkle);
                                setTimeout(() => sparkle.remove(), 1000);
                            }, i * 200);
                        }
                        break;
                }
            }
            
            setupPinInteractions(pin, type, config) {
                // Click to show details
                pin.addEventListener('click', (e) => {
                    e.stopPropagation();
                    window.sfOverPin = true;
                    this.showPinPopup(pin, type, config);
                });
                pin.addEventListener('mouseenter', () => { window.sfOverPin = true; });
                pin.addEventListener('mouseleave', () => { window.sfOverPin = false; });
                // Owner-only: long-press to delete (no admin required)
                let delTimer;
                const startOwnerPress = () => {
                    const isOwner = String(pin.dataset.userId) === String(window.currentUser?.id || '');
                    if (!isOwner) return;
                    delTimer = setTimeout(() => {
                        this.removePinAsOwner(pin);
                    }, 1000);
                };
                const cancelOwnerPress = () => { if (delTimer) clearTimeout(delTimer); };
                pin.addEventListener('touchstart', startOwnerPress, { passive: true });
                pin.addEventListener('touchend', cancelOwnerPress);
                pin.addEventListener('mousedown', startOwnerPress);
                pin.addEventListener('mouseup', cancelOwnerPress);
                pin.addEventListener('mouseleave', cancelOwnerPress);
                
                // Double tap for quick like
                let lastTap = 0;
                pin.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTap < 300) {
                        e.preventDefault();
                        this.quickLike(pin);
                    }
                    lastTap = now;
                });
                
                // Swipe gestures
                let touchStart = null;
                pin.addEventListener('touchstart', (e) => {
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                });
                
                pin.addEventListener('touchend', (e) => {
                    if (!touchStart) return;
                    const deltaX = e.changedTouches[0].clientX - touchStart.x;
                    if (Math.abs(deltaX) > 50) {
                        if (deltaX > 0) this.quickLike(pin);
                        else this.sharePin(pin);
                    }
                    touchStart = null;
                });
            }
            
            // Add/remove small delete badges based on moderation mode
            attachModerationBadge(pin) {
                // If already present, just ensure visibility follows mode
                let badge = pin.querySelector('.pin-delete-badge');
                if (!badge) {
                    badge = document.createElement('div');
                    badge.className = 'pin-delete-badge';
                    badge.textContent = '×';
                    badge.title = 'Delete pin (admin)';
                    // Do not let clicks bubble to open popup
                    badge.addEventListener('click', (e) => {
                        e.stopPropagation();
                        pin.remove();
                        showNotification('🗑️ Pin deleted (admin)', '#ff6b6b');
                    });
                    pin.appendChild(badge);
                }
                // Visibility handled via body.moderation-mode CSS
            }

            refreshModerationBadges() {
                if (!this.pinCanvas) return;
                const pins = this.pinCanvas.querySelectorAll('.enhanced-pin');
                pins.forEach(pin => {
                    // Only show admin badge if admin mode; otherwise remove
                    if (window.sfAdminEnabled) {
                        this.attachModerationBadge(pin);
                    } else {
                        pin.querySelector('.pin-delete-badge')?.remove();
                    }
                });
            }
            
            showPinPopup(pin, type, config) {
                // Create compact popup
                const isOwner = String(pin.dataset.userId) === String(window.currentUser?.id || '');
                const ownerName = pin.dataset.ownerName || 'Guest';
                const ownerPhoto = pin.dataset.ownerPhoto || '';
                const ownerInitial = ownerName.slice(0,1).toUpperCase();
                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 280px;
                    background: rgba(20, 20, 20, 0.98);
                    border-radius: 20px;
                    padding: 15px;
                    color: white;
                    z-index: 300;
                    animation: slideUp 0.3s ease;
                `;
                // Layout: header shows pin type and owner identity, actions below
                const avatarHtml = ownerPhoto
                    ? `<div style="width: 36px; height: 36px; border-radius: 50%; background:url('${ownerPhoto}') center/cover no-repeat; border:1px solid rgba(255,255,255,0.15);"></div>`
                    : `<div style="width: 36px; height: 36px; border-radius: 8px; display:grid; place-items:center; color:#000; font-weight:800; border:1px solid rgba(255,255,255,0.15); background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.85), ${config.color});">${ownerInitial}</div>`;
                popup.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        ${avatarHtml}
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 700;">${ownerName}</div>
                            <div style="font-size: 12px; opacity: 0.7;">Pin ${type} • Just now</div>
                        </div>
                        <button data-close-pin-popup="1" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">×</button>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 12px;">
                        <button style="flex: 1; padding: 8px; background: rgba(255,255,255,0.1); border: none; border-radius: 10px; color: white; cursor: pointer;">❤️ Like</button>
                        <button style="flex: 1; padding: 8px; background: rgba(255,255,255,0.1); border: none; border-radius: 10px; color: white; cursor: pointer;">💬 Reply</button>
                    </div>
                    <div style="display:block; margin-top: 10px;">
                        <button style="display:block; width:100%; padding: 10px; background: linear-gradient(135deg, #4f46e5, #7c3aed); border: none; border-radius: 12px; color: white; cursor: pointer; font-weight:600;">📤 Share</button>
                    </div>
                    ${isOwner ? '<div style="display:flex; justify-content:flex-end; margin-top: 10px;"><button id="ownerDeletePin" style="padding: 6px 10px; background: rgba(255, 0, 0, 0.18); border: none; border-radius: 10px; color: #ff9a9a; cursor: pointer;">🗑️ Delete</button></div>' : ''}
                `;
                document.body.appendChild(popup);
                // Flag popup open to suppress other-people UI
                window.sfPinPopupOpen = true;
                // Hide hover card while popup is open
                try { window.socialFloor?.hideHoverCard(); } catch {}
                // Group chat removed
                // Close button clears the flag
                popup.querySelector('[data-close-pin-popup]')?.addEventListener('click', () => {
                    popup.remove();
                    window.sfPinPopupOpen = false;
                });
                // Wire owner delete if present
                if (isOwner) {
                    popup.querySelector('#ownerDeletePin')?.addEventListener('click', () => {
                        this.removePinAsOwner(pin);
                        popup.remove();
                        window.sfPinPopupOpen = false;
                    });
                }
                setTimeout(() => { popup.remove(); window.sfPinPopupOpen = false; }, 5000);
            }
            
            quickLike(pin) {
                const heart = document.createElement('div');
                heart.textContent = '❤️';
                heart.style.cssText = `
                    position: absolute;
                    font-size: 20px;
                    animation: floatUp 1s ease forwards;
                    pointer-events: none;
                `;
                pin.appendChild(heart);
                setTimeout(() => heart.remove(), 1000);
            }
            
            sharePin(pin) {
                if (navigator.share) {
                    navigator.share({
                        title: 'Sound Factory Pin',
                        text: 'Check out this moment!',
                        url: window.location.href
                    });
                }
            }

            removePinAsOwner(pin) {
                const isOwner = String(pin.dataset.userId) === String(window.currentUser?.id || '');
                if (!isOwner) return;
                try {
                    pin.remove();
                    this.pinMeta.delete(pin);
                    if (window.currentUser?.id) this.userPins.delete(window.currentUser.id);
                    // Allow dropping a new pin again
                    if (window.currentUser) {
                        window.currentUser.hasDroppedPin = false;
                        try { localStorage.setItem('sf_user_pin_used', '0'); } catch {}
                    }
                    showNotification('🗑️ Your pin was deleted', '#ff6b6b');
                } catch {}
            }
        }

        // Initialize systems
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize SMS verification gate FIRST
            window.smsGate = new SMSVerificationGate();
            window.smsGate.startVerificationCheck();
            
            // Initialize floor navigation system
            window.floorNavigation = new FloorNavigationSystem();
            
            // Initialize social floor system
            window.socialFloor = new SocialFloor();
            
            // Initialize enhanced pin system
            window.pinSystem = new EnhancedPinSystem();
        
        // Initialize social media live share system
        window.liveShare = new SocialMediaLiveShare(
            window.location.href,
            'Sound Factory NYC - Live DJ Set'
        );
        
        
        
        // Initialize swipe controls for floor navigation
        initSwipeControls();
        
        // Initialize integrated chat system



        // Swipe Controls for Floor Navigation
        function initSwipeControls() {
            let startY = 0;
            let startX = 0;
            let isSwipe = false;
            
            const floors = ['b', 'mf', 'mz', '2', '3'];
            let currentFloorIndex = 1; // Start at main floor (mf)
            
            // Touch events
            document.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
                startX = e.touches[0].clientX;
                isSwipe = true;
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!isSwipe) return;
                e.preventDefault();
            });
            
            document.addEventListener('touchend', (e) => {
                if (!isSwipe) return;
                
                const endY = e.changedTouches[0].clientY;
                const endX = e.changedTouches[0].clientX;
                const deltaY = startY - endY;
                const deltaX = startX - endX;
                
                // Check if it's a vertical swipe (not horizontal)
                if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > 50) {
                    if (deltaY > 0) {
                        // Swipe up - go to higher floor
                        if (currentFloorIndex < floors.length - 1) {
                            currentFloorIndex++;
                            changeFloor(floors[currentFloorIndex]);
                        }
                    } else {
                        // Swipe down - go to lower floor
                        if (currentFloorIndex > 0) {
                            currentFloorIndex--;
                            changeFloor(floors[currentFloorIndex]);
                        }
                    }
                }
                
                isSwipe = false;
            });
            
            // Mouse events for desktop
            let mouseStartY = 0;
            let mouseStartX = 0;
            let isMouseSwipe = false;
            
            document.addEventListener('mousedown', (e) => {
                mouseStartY = e.clientY;
                mouseStartX = e.clientX;
                isMouseSwipe = true;
            });
            
            document.addEventListener('mouseup', (e) => {
                if (!isMouseSwipe) return;
                
                const mouseEndY = e.clientY;
                const mouseEndX = e.clientX;
                const mouseDeltaY = mouseStartY - mouseEndY;
                const mouseDeltaX = mouseStartX - mouseEndX;
                
                // Check if it's a vertical swipe (not horizontal)
                if (Math.abs(mouseDeltaY) > Math.abs(mouseDeltaX) && Math.abs(mouseDeltaY) > 50) {
                    if (mouseDeltaY > 0) {
                        // Swipe up - go to higher floor
                        if (currentFloorIndex < floors.length - 1) {
                            currentFloorIndex++;
                            changeFloor(floors[currentFloorIndex]);
                        }
                    } else {
                        // Swipe down - go to lower floor
                        if (currentFloorIndex > 0) {
                            currentFloorIndex--;
                            changeFloor(floors[currentFloorIndex]);
                        }
                    }
                }
                
                isMouseSwipe = false;
            });
            
            function changeFloor(floorId) {
                // Hide all floors
                document.querySelectorAll('.floor').forEach(floor => {
                    floor.classList.remove('active');
                });
                
                // Show selected floor
                const targetFloor = document.getElementById(`floor-${floorId}`);
                if (targetFloor) {
                    targetFloor.classList.add('active');
                }
                
                // Update floor navigation if it exists
                if (window.floorNavigation) {
                    window.floorNavigation.currentFloor = floorId;
                }
                
                // Show notification
                const floorNames = {
                    'b': 'Basement',
                    'mf': 'Main Floor',
                    'mz': 'Mezzanine',
                    '2': 'Second Floor',
                    '3': 'Third Floor'
                };
                
                showNotification(`🏢 ${floorNames[floorId]}`, '#ff6b35');
            }
        }

        // Integrated Chat System
        function initIntegratedChat() {
            const chatSystem = document.getElementById('sf-chat-system');
            const chatToggle = document.getElementById('sfChatToggle');
            const chatInput = document.getElementById('sfChatInput');
            const chatSend = document.getElementById('sfChatSend');
            const chatMessages = document.getElementById('sfChatMessages');
            
            if (!chatSystem || !chatToggle) return;
            
            // Toggle chat expansion
            chatToggle.addEventListener('click', () => {
                chatSystem.classList.toggle('expanded');
                if (chatSystem.classList.contains('expanded')) {
                    chatInput.focus();
                }
            });
            
            // Send message
            function sendMessage() {
                const message = chatInput.value.trim();
                if (!message) return;
                
                // Add user message
                addMessage(message, 'user');
                chatInput.value = '';
                
                // Simulate AI response (you can replace with real AI)
                setTimeout(() => {
                    const aiResponses = [
                        "That sounds amazing! 🔥",
                        "I'm feeling the energy tonight! 💃",
                        "This place is incredible! ✨",
                        "Who's ready to dance? 🎵",
                        "The vibes are perfect! 🌟"
                    ];
                    const randomResponse = aiResponses[Math.floor(Math.random() * aiResponses.length)];
                    addMessage(randomResponse, 'ai');
                }, 1000);
            }
            
            // Add message to chat
            function addMessage(text, type) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `sf-chat-message ${type}`;
                
                const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                messageDiv.innerHTML = `
                    <div class="sf-message-text">${text}</div>
                    <div class="sf-message-time">${time}</div>
                `;
                
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            // Event listeners
            chatSend.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            // Update mode button selectors
            const modeButtons = document.querySelectorAll('.cool-mode-btn');
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    modeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });
        }
        
        // Live Share Button Event Listener
        document.getElementById('liveShareBtn').addEventListener('click', function() {
            // Initialize social media share system
            if (window.liveShare) {
                // Show share options
                window.liveShare.createShareButtons();
                showNotification('📡 Live share system activated!', '#ff0000');
            }
        });
        
        // Setup WebSocket event handlers for real-time pin updates
            if (window.soundFactoryWS) {
                // Handle incoming pins from other users
                window.soundFactoryWS.setOnPinCreate((pin) => {
                    console.log('📍 Received pin from other user:', pin);
                    createRemotePin(pin);
                });
                
                window.soundFactoryWS.setOnPinUpdate((pin) => {
                    console.log('📍 Pin updated by other user:', pin);
                    updateRemotePin(pin);
                });
                
                window.soundFactoryWS.setOnPinDelete((pinId) => {
                    console.log('📍 Pin deleted by other user:', pinId);
                    deleteRemotePin(pinId);
                });
                
                window.soundFactoryWS.setOnConnect(() => {
                    console.log('🔌 Connected to real-time pin sharing');
                    showNotification('🔌 Connected to live floor', '#00ff88');
                });
                
                window.soundFactoryWS.setOnDisconnect(() => {
                    console.log('🔌 Disconnected from real-time pin sharing');
                    showNotification('⚠️ Disconnected from live floor', '#ffcc00');
                });
            }
            
            // Functions to handle remote pins from other users
            function createRemotePin(pinData) {
                if (!window.pinSystem) return;
                
                const pin = document.createElement('div');
                pin.className = 'enhanced-pin remote-pin';
                pin.dataset.remoteId = pinData.id;
                pin.dataset.userId = pinData.userId;
                pin.dataset.userName = pinData.userName;
                pin.style.cssText = `
                    position: absolute;
                    left: ${pinData.x}%;
                    top: ${pinData.y}%;
                    width: 15px;
                    height: 15px;
                    border-radius: 50% 50% 50% 0;
                    background: ${pinData.color};
                    transform: rotate(-45deg) translate(-50%, -50%);
                    cursor: pointer;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    animation: dropIn 0.5s ease;
                    opacity: 0.8;
                `;
                pin.title = `${pinData.userName} • ${pinData.type}`;
                pin.classList.add('dimmed');
                
                // Add to pin canvas
                if (window.pinSystem.pinCanvas) {
                    window.pinSystem.pinCanvas.appendChild(pin);
                }
                
                // Setup interactions
                pin.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showRemotePinPopup(pinData);
                });
                
                console.log('📍 Remote pin created:', pinData.userName);
            }
            
            function updateRemotePin(pinData) {
                const pin = document.querySelector(`[data-remote-id="${pinData.id}"]`);
                if (pin) {
                    pin.style.left = `${pinData.x}%`;
                    pin.style.top = `${pinData.y}%`;
                    pin.style.background = pinData.color;
                    pin.title = `${pinData.userName} • ${pinData.type}`;
                    console.log('📍 Remote pin updated:', pinData.userName);
                }
            }
            
            function deleteRemotePin(pinId) {
                const pin = document.querySelector(`[data-remote-id="${pinId}"]`);
                if (pin) {
                    pin.remove();
                    console.log('📍 Remote pin deleted:', pinId);
                }
            }
            
            function showRemotePinPopup(pinData) {
                const popup = document.createElement('div');
                popup.className = 'pin-popup remote';
                popup.innerHTML = `
                    <div class="pin-popup-content">
                        <div class="pin-user-info">
                            <div class="pin-user-avatar" style="background: ${pinData.color}"></div>
                            <div class="pin-user-details">
                                <div class="pin-user-name">${pinData.userName}</div>
                                <div class="pin-user-message">${pinData.message}</div>
                            </div>
                        </div>
                        <div class="pin-actions">
                            <button class="pin-action-btn" onclick="this.closest('.pin-popup').remove()">Close</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(popup);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (popup.parentNode) popup.remove();
                }, 5000);
            }
            
            // Simple click-anywhere pin creation system
            function initSimplePinSystem() {
                console.log('🎯 Initializing simple pin system...');
                
                // Add click listener to the main floor area
                const floorArea = document.querySelector('.floor-container') || 
                                 document.querySelector('#floorContainer') || 
                                 document.querySelector('.dancefloor') ||
                                 document.body;
                
                if (floorArea) {
                    floorArea.addEventListener('click', (e) => {
                        // Only create pins if in drop mode
                        if (window.appMode !== 'drop') return;
                        
                        // Check if user is verified
                        if (!window.smsGate?.isVerified) {
                            showNotification('🔒 Please verify your phone to drop pins', '#ff6b6b');
                            return;
                        }
                        
                        // Check if user already dropped a pin
                        if (window.currentUser?.hasDroppedPin) {
                            showNotification('📍 You can only drop one pin', '#ffcc00');
                            return;
                        }
                        
                        // Show pin creation modal
                        showPinCreationModal(e.clientX, e.clientY);
                    });
                    
                    console.log('✅ Simple pin system initialized');
                } else {
                    console.log('❌ No floor area found for pin dropping');
                }
            }
            
            // Show pin creation modal
            function showPinCreationModal(x, y) {
                const modal = document.getElementById('pinCreationModal');
                if (modal) {
                    modal.style.display = 'block';
                    
                    // Store click position
                    window.pendingPinPosition = { x, y };
                    
                    // Setup modal event handlers
                    setupPinModalHandlers();
                }
            }
            
            // Setup pin modal handlers
            function setupPinModalHandlers() {
                const modal = document.getElementById('pinCreationModal');
                const messageInput = document.getElementById('pinMessage');
                const charCount = document.getElementById('charCount');
                const createBtn = document.getElementById('createPinBtn');
                const cancelBtn = document.getElementById('cancelPinBtn');
                const typeButtons = document.querySelectorAll('.pin-type-btn');
                
                let selectedType = 'moment';
                
                // Clear any existing event listeners
                if (createBtn) {
                    createBtn.replaceWith(createBtn.cloneNode(true));
                }
                if (cancelBtn) {
                    cancelBtn.replaceWith(cancelBtn.cloneNode(true));
                }
                
                // Get fresh references after cloning
                const freshCreateBtn = document.getElementById('createPinBtn');
                const freshCancelBtn = document.getElementById('cancelPinBtn');
                
                // Character count
                if (messageInput && charCount) {
                    messageInput.addEventListener('input', () => {
                        charCount.textContent = messageInput.value.length;
                    });
                }
                
                // Type selection
                typeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        typeButtons.forEach(b => b.style.opacity = '0.5');
                        btn.style.opacity = '1';
                        selectedType = btn.dataset.type;
                    });
                });
                
                // Create pin
                if (freshCreateBtn) {
                    freshCreateBtn.addEventListener('click', () => {
                        const message = messageInput ? messageInput.value.trim() : '';
                        console.log('Creating pin with:', { x: window.pendingPinPosition.x, y: window.pendingPinPosition.y, message, selectedType });
                        createSimplePin(window.pendingPinPosition.x, window.pendingPinPosition.y, message, selectedType);
                        modal.style.display = 'none';
                    });
                }
                
                // Cancel
                if (freshCancelBtn) {
                    freshCancelBtn.addEventListener('click', () => {
                        modal.style.display = 'none';
                    });
                }
                
                // Close on backdrop click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                });
            }
            
            // Create an enhanced pin with better styling
            function createSimplePin(x, y, message, type) {
                console.log('📍 Creating enhanced pin:', { x, y, message, type });
                
                // Create pin container
                const pin = document.createElement('div');
                pin.className = 'enhanced-pin';
                pin.style.cssText = `
                    position: fixed;
                    left: ${x}px;
                    top: ${y}px;
                    width: 30px;
                    height: 40px;
                    cursor: pointer;
                    transform: translate(-50%, -100%);
                    animation: pinDrop 0.5s ease;
                    z-index: 1000;
                `;
                
                // Create pin marker with gradient
                const marker = document.createElement('div');
                marker.style.cssText = `
                    width: 30px;
                    height: 40px;
                    background: linear-gradient(135deg, #FFD700, #FF6B35);
                    border-radius: 50% 50% 50% 0;
                    transform: rotate(-45deg);
                    box-shadow: 0 0 10px rgba(255,215,0,0.5);
                `;
                
                // Add user initials
                const initials = document.createElement('div');
                initials.style.cssText = `
                    position: absolute;
                    top: 8px;
                    left: 50%;
                    transform: translateX(-50%) rotate(45deg);
                    font-size: 10px;
                    font-weight: 700;
                    color: #000;
                `;
                initials.textContent = window.currentUser?.initials || 'U';
                
                marker.appendChild(initials);
                pin.appendChild(marker);
                
                // Store pin data
                pin.setAttribute('data-story', message);
                pin.setAttribute('data-user', window.currentUser?.id || 'anonymous');
                pin.setAttribute('data-name', window.currentUser?.name || 'Anonymous');
                pin.setAttribute('data-type', type);
                
                // Add hover events
                pin.addEventListener('mouseenter', showPinHover);
                pin.addEventListener('mouseleave', hidePinHover);
                pin.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showPinHover(e);
                });
                
                // Add to page
                document.body.appendChild(pin);
                
                // Mark user as having dropped a pin
                if (window.currentUser) {
                    window.currentUser.hasDroppedPin = true;
                }
                
                // Save to Supabase if available
                if (window.supabase) {
                    savePinToSupabase(x, y, message, type);
                }
                
                // Broadcast via WebSocket if available
                if (window.soundFactoryWS && window.soundFactoryWS.isConnected()) {
                    const pinData = {
                        x: (x / window.innerWidth) * 100, // Convert to percentage
                        y: (y / window.innerHeight) * 100,
                        message: message,
                        type: type,
                        userId: window.currentUser?.id || 'anonymous',
                        userName: window.currentUser?.name || 'Anonymous'
                    };
                    window.soundFactoryWS.createPin(pinData);
                }
                
                showNotification('✅ Pin dropped!', '#00ff88');
            }
            
            // Show pin hover card
            function showPinHover(event) {
                const pin = event.currentTarget;
                const card = document.getElementById('pinHoverCard');
                
                const story = pin.getAttribute('data-story');
                const name = pin.getAttribute('data-name');
                const type = pin.getAttribute('data-type');
                
                document.getElementById('hoverName').textContent = name;
                document.getElementById('hoverStory').textContent = story;
                
                // Position card above pin
                const rect = pin.getBoundingClientRect();
                card.style.left = rect.left + 'px';
                card.style.top = (rect.top - 10) + 'px';
                card.style.display = 'block';
                card.style.pointerEvents = 'auto';
            }
            
            // Hide pin hover card
            function hidePinHover() {
                const card = document.getElementById('pinHoverCard');
                card.style.display = 'none';
                card.style.pointerEvents = 'none';
            }
            
            // Pin interaction functions
            function likePin() {
                showNotification('❤️ Pin liked!', '#ff6b6b');
                hidePinHover();
            }
            
            function sharePin() {
                showNotification('📤 Pin shared!', '#00ff88');
                hidePinHover();
            }
            
            function commentPin() {
                const comment = prompt('Add your comment:');
                if (comment) {
                    showNotification('💬 Comment added!', '#ffd700');
                }
                hidePinHover();
            }
            
            // Save pin to Supabase
            async function savePinToSupabase(x, y, message, type) {
                if (!window.supabase) return;
                
                try {
                    const { data, error } = await window.supabase.from('pins').insert({
                        user_id: window.currentUser?.id || 'anonymous',
                        x_position: Math.round(x),
                        y_position: Math.round(y),
                        message: message,
                        color: '#ff6b00',
                        type: type
                    });
                    
                    if (error) {
                        console.error('❌ Supabase save error:', error);
                    } else {
                        console.log('✅ Pin saved to Supabase:', data);
                    }
                } catch (err) {
                    console.error('❌ Supabase save error:', err);
                }
            }
            
            // Initialize simple pin system
            initSimplePinSystem();
            
            // Debug: Test pin system
            console.log('🎯 Pin system initialized');
            console.log('📍 Modal element:', document.getElementById('pinCreationModal'));
            console.log('📍 Create button:', document.getElementById('createPinBtn'));
            
            // If already verified (bypass), ensure user init happens
            if (window.smsGate?.isVerified) window.initCurrentUser();

            // Start pin live/dim check and auto-expire
            setInterval(() => {
                try {
                    const pins = document.querySelectorAll('.enhanced-pin');
                    const me = window.sfUserPosition;
                    pins.forEach(pin => {
                        const meta = window.pinSystem.pinMeta.get(pin);
                        if (!meta) return;
                        // Only consider when on same floor as pin
                        const sameFloor = me && meta.floor && (me.floor === meta.floor);
                        if (sameFloor) {
                            // Convert percent coords back to px relative to viewport
                            const rect = window.pinSystem.pinCanvas.getBoundingClientRect();
                            const leftPct = parseFloat(pin.style.left);
                            const topPct = parseFloat(pin.style.top);
                            const pinX = rect.left + (isNaN(leftPct)?0:leftPct/100 * rect.width);
                            const pinY = rect.top + (isNaN(topPct)?0:topPct/100 * rect.height);
                            const dx = (me.x || 0) - pinX;
                            const dy = (me.y || 0) - pinY;
                            const dist = Math.hypot(dx, dy);
                            const near = dist < PIN_NEAR_RADIUS; // within configured radius counts as near
                            if (near) {
                                pin.classList.add('live');
                                pin.classList.remove('dimmed');
                                meta.lastSeenTs = Date.now();
                            } else {
                                pin.classList.remove('live');
                                pin.classList.add('dimmed');
                            }
                        } else {
                            // Different floor -> dim
                            pin.classList.remove('live');
                            pin.classList.add('dimmed');
                        }
                        // Auto-expire if not seen for > 60s
                        if (Date.now() - meta.lastSeenTs > PIN_TTL_MS) {
                            const isOwner = String(pin.dataset.userId) === String(window.currentUser?.id || '');
                            if (isOwner) {
                                window.pinSystem.removePinAsOwner(pin);
                                showNotification('⌛ Your pin expired', '#9aa3b2');
                            } else {
                                // Non-owner pin (future multi-user) just remove silently
                                try { pin.remove(); } catch {}
                            }
                        }
                    });
                } catch {}
            }, 1500);

            // Flyer dismiss + remember: hide if user closed it
            try {
                const hidden = (localStorage.getItem('sf_flyer_hidden') === '1');
                document.querySelectorAll('.floor-flyer').forEach(f => {
                    if (hidden) f.style.display = 'none';
                    const img = f.querySelector('img');
                    if (img && !img.getAttribute('src')) img.setAttribute('src', 'seance-flyer.jpg');
                    f.querySelector('.flyer-dismiss')?.addEventListener('click', (e) => {
                        e.stopPropagation();
                        document.querySelectorAll('.floor-flyer').forEach(el => el.style.display = 'none');
                        localStorage.setItem('sf_flyer_hidden', '1');
                    });
                    const a = f.querySelector('a');
                    if (a) a.setAttribute('href', TICKET_URL);
                });

                // Long-press on floor hint to preview flyer (per-floor)
                document.querySelectorAll('.floor-hint').forEach(hint => {
                    let pressTimer;
                    const start = () => { pressTimer = setTimeout(()=>{ try { window.showFloatingFlyer?.(); } catch {} }, 500); };
                    const cancel = () => { if (pressTimer) clearTimeout(pressTimer); };
                    hint.addEventListener('touchstart', start, { passive: true });
                    hint.addEventListener('touchend', cancel);
                    hint.addEventListener('touchmove', cancel);
                    hint.addEventListener('mousedown', start);
                    hint.addEventListener('mouseup', cancel);
                    hint.addEventListener('mouseleave', cancel);
                });
            } catch {}

            // Long-press the subtle floor hint to preview flyer
            try {
                document.querySelectorAll('.floor-hint').forEach(h => {
                    let lpT;
                    const start = () => { lpT = setTimeout(()=>{ try { window.showFloatingFlyer?.(); } catch {} }, 600); };
                    const cancel = () => { if (lpT) clearTimeout(lpT); };
                    h.addEventListener('touchstart', start, { passive: true });
                    h.addEventListener('touchend', cancel);
                    h.addEventListener('touchmove', cancel);
                    h.addEventListener('mousedown', start);
                    h.addEventListener('mouseup', cancel);
                    h.addEventListener('mouseleave', cancel);
                });
            } catch {}
        });

        // Social Floor Functions
        function setWalkStyle(style) {
            if (!window.socialFloor) return;
            
            window.socialFloor.walkStyle = style;
            window.socialFloor.myCharacter.className = `character ${style === 'normal' ? 'walking' : style}`;
            
            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Apply to others too
            window.socialFloor.others.forEach(other => {
                if (Math.random() > 0.5) {
                    other.element.className = `character ${style === 'normal' ? 'walking' : style}`;
                }
            });
        }

        function addPerson() {
            if (!window.socialFloor) return;
            
            const colors = ['#ff00ff', '#00ffff', '#ffd700', '#ff6b35'];
            const avatars = ['#ff9', '#9ff', '#f9f', '#cfc', '#fc9'];
            const other = document.createElement('div');
            other.className = 'character walking';
            other.style.setProperty('--color', colors[Math.floor(Math.random() * colors.length)]);
            other.innerHTML = `
                <div class="proximity-ring"></div>
                <div class="head"></div>
                <div class="arm left"></div>
                <div class="arm right"></div>
                <div class="leg left"></div>
                <div class="leg right"></div>
                <div class="chat-bubble"></div>
            `;
            
            const data = {
                element: other,
                name: 'Person ' + (window.socialFloor.others.length + 1),
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                targetX: Math.random() * window.innerWidth,
                targetY: Math.random() * window.innerHeight,
                floor: window.socialFloor.currentFloor, // Add to current floor
                avatarColor: avatars[Math.floor(Math.random()*avatars.length)],
                likes: 0,
                comments: []
            };
            
            window.socialFloor.others.push(data);
            document.getElementById('othersContainer').appendChild(other);
            other.addEventListener('click', () => window.socialFloor.showHoverCard(data));
            other.addEventListener('touchend', () => window.socialFloor.showHoverCard(data));
            window.socialFloor.updatePeopleCount();
        }

        async function buyDrink() {
            try {
                // Prefer server-created Stripe Checkout Session
                const res = await fetch('/.netlify/functions/create-checkout-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        item: 'drink',
                        userId: window.currentUser?.id || null,
                        userName: window.currentUser?.name || null
                    })
                });
                if (res.ok) {
                    const data = await res.json();
                    if (data.url) {
                        showNotification('🍹 Opening drink checkout…', '#ff00ff');
                        window.location.href = data.url;
                        return;
                    }
                }
                // Fallback to static DRINK_URL
                window.open(DRINK_URL, '_blank', 'noopener');
                showNotification('🍹 Opening drink checkout…', '#ff00ff');
            } catch {
                // Fallback on any error
                try { window.open(DRINK_URL, '_blank', 'noopener'); } catch {}
                showNotification('🍹 Opening drink checkout…', '#ff00ff');
            }
        }

        function buyTicket() {
            try { window.open(TICKET_URL, '_blank', 'noopener'); } catch {}
            showNotification('🎫 Opening tickets…', '#ffd700');
        }

        function likeUser() {
            showNotification('❤️ Liked!', '#ff6b35');
        }

        async function shareContact() {
            try {
                const url = location.href.split('#')[0];
                const title = 'Sound Factory NYC';
                if (navigator.share) {
                    await navigator.share({ title, url });
                    showNotification('🔗 Shared!', '#00ffff');
                } else if (navigator.clipboard?.writeText) {
                    await navigator.clipboard.writeText(url);
                    showNotification('🔗 Link copied', '#00ffff');
                } else {
                    // Fallback: open share sheet via mailto
                    window.open(`mailto:?subject=${encodeURIComponent(title)}&body=${encodeURIComponent(url)}`);
                }
            } catch (e) {
                showNotification('⚠️ Unable to share', '#ff6b6b');
            }
        }

        function showNotification(text, color) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            // Use provided color if any, otherwise white; keep monochrome theme
            notif.style.setProperty('--color', color || '#ffffff');
            notif.textContent = text;
            document.body.appendChild(notif);
            
            setTimeout(() => notif.remove(), 2000);
            // Also broadcast unified notification event with basic payload for toasts
            try {
                const payload = { title: 'Sound Factory', body: text, icon: 'sf-logo.png', tag: 'toast' };
                window.dispatchEvent(new CustomEvent('sf:notification', { detail: payload }));
            } catch {}
        }

        // Profile card button actions
        document.addEventListener('DOMContentLoaded', () => {
            const likeBtn = document.getElementById('pcLike');
            const commentBtn = document.getElementById('pcComment');
            const shareBtn = document.getElementById('pcShare');
            
            likeBtn?.addEventListener('click', () => {
                if (window.socialFloor?.closestPerson) {
                    window.socialFloor.closestPerson.likes++;
                    showNotification(`❤️ Liked ${window.socialFloor.closestPerson.name}`, '#ff6b6b');
                }
            });
            commentBtn?.addEventListener('click', () => {
                if (!window.socialFloor?.closestPerson) return;
                const text = prompt('Leave a comment:');
                if (text && text.trim()) {
                    window.socialFloor.closestPerson.comments.push(text.trim());
                    showNotification('💬 Comment added', '#9b7bff');
                }
            });
            shareBtn?.addEventListener('click', async () => {
                if (!window.socialFloor?.closestPerson) return;
                try {
                    if (navigator.share) {
                        await navigator.share({
                            title: 'Sound Factory',
                            text: `Hanging with ${window.socialFloor.closestPerson.name} at SF NYC` ,
                            url: window.location.href
                        });
                    } else {
                        await navigator.clipboard.writeText(window.location.href);
                        showNotification('🔗 Link copied', '#00ffff');
                    }
                } catch (_) {}
            });

            // New drink/ticket actions
            const drinkBtn = document.getElementById('pcDrink');
            const ticketBtn = document.getElementById('pcTicket');
            drinkBtn?.addEventListener('click', () => {
                try { window.open(DRINK_URL, '_blank', 'noopener'); } catch {}
                showNotification('🍹 Opening drink checkout…', '#ff00ff');
            });
            ticketBtn?.addEventListener('click', () => {
                try { window.open(TICKET_URL, '_blank', 'noopener'); } catch {}
                showNotification('🎫 Opening tickets…', '#ffd700');
            });
        });

        // Ambient date particles (subtle 11.1 floaters)
        function initAmbientDateParticles() {
            // Inject animation keyframes once
            if (!document.getElementById('dateParticleStyles')) {
                const particleStyle = document.createElement('style');
                particleStyle.id = 'dateParticleStyles';
                particleStyle.textContent = `
                    @keyframes floatAcross {
                        from { transform: translateX(0) translateY(0); opacity: 0; }
                        10% { opacity: 0.3; }
                        90% { opacity: 0.3; }
                        to { transform: translateX(calc(100vw + 100px)) translateY(-20px); opacity: 0; }
                    }
                `;
                document.head.appendChild(particleStyle);
            }
            setInterval(() => {
                if (Math.random() > 0.95) {
                    const particle = document.createElement('div');
                    particle.textContent = '11.1';
                    particle.style.cssText = `
                        position: fixed; left: -50px; top: ${Math.random() * window.innerHeight}px;
                        color: rgba(255, 0, 255, 0.28); font-size: ${10 + Math.random() * 5}px; font-weight: 800;
                        animation: floatAcross 15s linear forwards; pointer-events: none; z-index: 1;
                    `;
                    document.body.appendChild(particle);
                    setTimeout(() => particle.remove(), 15000);
                }
            }, 3000);
        }

        // Profile card subtle flyer and badge
        function enhanceProfileCards() {
            if (document.getElementById('profileCardStyles')) return;
            const style = document.createElement('style');
            style.id = 'profileCardStyles';
            style.textContent = `
                .profile-card::before { content: ''; position: absolute; inset: 0;
                    background: url('seance-flyer.jpg') center/cover no-repeat; opacity: 0.05; z-index: -1;
                    filter: blur(10px); transition: opacity 0.3s ease, filter 0.3s ease; }
                .profile-card:hover::before { opacity: 0.1; filter: blur(5px); }
                .profile-card::after { content: '👻'; position: absolute; top: 5px; right: 5px; font-size: 12px; animation: ghostWiggle 2s ease-out infinite; }
                @keyframes ghostWiggle { 0%,100%{transform:rotate(0)} 25%{transform:rotate(-10deg)} 75%{transform:rotate(10deg)} }
            `;
            document.head.appendChild(style);
        }

        // SMS Profile Bridge: fetch profile once verified
        window.SMSProfileBridge = {
            syncUserProfile: function() {
                try {
                    const phone = localStorage.getItem('sf_phone');
                    const user = JSON.parse(localStorage.getItem('sf_user') || '{}');
                    if (!phone || user.synced) return;
                    fetch('/.netlify/functions/get-fan-profile', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ phone })
                    }).then(res => res.json()).then(profile => {
                        user.name = profile?.name || user.name;
                        user.photo = profile?.photo || user.photo;
                        user.vipStatus = profile?.audience_bucket === 'core';
                        user.inviteCode = profile?.invite_code;
                        user.synced = true;
                        localStorage.setItem('sf_user', JSON.stringify(user));
                        if (user.photo) applyUserPhoto(user.photo);
                    }).catch(()=>{});
                } catch {}
            }
        };

        // Basic WebSocket manager (stubbed endpoints)
        class SoundFactorySocket {
            constructor(){ this.ws = null; this.reconnectAttempts = 0; }
            connect(){
                const token = (document.cookie.match(/(?:^|; )sf_token=([^;]+)/)||[])[1];
                if (!token) return;
                try {
                    this.ws = new WebSocket('wss://sf-realtime.soundfactorynyc.com');
                    this.ws.onopen = () => { /* auth + presence could go here */ };
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            switch(data.type){
                                case 'pin_dropped':
                                    window.pinSystem?.addExternalPin?.({
                                        x: data.pin?.xPct || 50, y: data.pin?.yPct || 50, color: '#ff0066', type: 'moment',
                                        ownerName: data.pin?.ownerName || 'Guest', ownerPhoto: data.pin?.ownerPhoto || '', floor: data.pin?.floor || 'mf'
                                    });
                                    break;
                                case 'message':
                                    showNotification(data.message || 'New message');
                                    break;
                            }
                        } catch {}
                    };
                } catch {}
            }
        }

        // Social connections manager (visual stubs)
        window.SocialGraph = {
            connections: new Map(),
            addConnection: function(userId, type='friend'){
                const phone = localStorage.getItem('sf_phone');
                try { fetch('/.netlify/functions/add-connection', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ from: phone, to: userId, type }) }); } catch {}
                showNotification('🔗 Connection sent', '#00ffff');
            },
            showMutualConnections: function(){ /* could highlight characters if we had them as DOM nodes */ }
        };

        // Unified Notification Center (listens to sf:notification)
        class NotificationCenter {
            constructor(){ this.permissions = 'default'; this.stack = null; }
            async init(){
                if ('Notification' in window) {
                    try { this.permissions = await Notification.requestPermission(); } catch {}
                }
                this.ensureStack();
                window.addEventListener('sf:notification', (e)=> this.show(e.detail));
            }
            ensureStack(){
                if (!this.stack){ this.stack = document.createElement('div'); this.stack.id = 'toastStack'; document.body.appendChild(this.stack); }
            }
            show(n){
                if (!n) return;
                const toast = document.createElement('div');
                toast.className = 'notification-toast';
                const icon = n.icon || 'sf-logo.png';
                toast.innerHTML = `<img src="${icon}" alt=""/><div><strong>${n.title||'Sound Factory'}</strong><p>${n.body||''}</p></div>`;
                this.stack.appendChild(toast);
                setTimeout(()=> toast.remove(), 2500);
                if (this.permissions === 'granted' && 'Notification' in window) {
                    try { new Notification(n.title||'Sound Factory', { body: n.body||'', icon, tag: n.tag||'sf' }); } catch {}
                }
            }
        }

        // Initialize extras after DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            try { initAmbientDateParticles(); } catch {}
            try { enhanceProfileCards(); } catch {}
            try { window.SMSProfileBridge?.syncUserProfile?.(); } catch {}
            try { (new NotificationCenter()).init(); } catch {}
            // Optionally: start sockets when verified
            if (window.smsGate?.isVerified) { try { (new SoundFactorySocket()).connect(); } catch {} }
            // Re-attempt sockets on auth
            window.addEventListener('sf:auth', () => { try { (new SoundFactorySocket()).connect(); } catch {} });
        });
    </script>
    
    <!-- Countdown Timer Script -->
    <script>
        // Countdown to November 1st
        function updateCountdown() {
            const targetDate = new Date('November 1, 2025 00:00:00').getTime();
            const now = new Date().getTime();
            const timeRemaining = targetDate - now;
            
            if (timeRemaining <= 0) {
                document.getElementById('countdown').innerHTML = "We're Open!";
                return;
            }
            
            const days = Math.floor(timeRemaining / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
            
            // Format the countdown display
            if (days > 0) {
                document.getElementById('countdown').innerHTML = `${days}d ${hours}h ${minutes}m`;
            } else {
                document.getElementById('countdown').innerHTML = `${hours}h ${minutes}m ${seconds}s`;
            }
        }
        
        // Update countdown immediately and then every second
        updateCountdown();
        setInterval(updateCountdown, 1000);


    // Premium Chat UI fully removed; no modular component is loaded

        // AI Vocal Studio System
        class AIVocalStudio {
            constructor() {
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.stream = null;
                this.audioContext = null;
                this.analyser = null;
                this.startTime = null;
                this.timerInterval = null;
                this.canvas = null;
                this.ctx = null;
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.setupCanvas();
            }
            
            setupEventListeners() {
                // Open/Close Studio
                document.getElementById('vocalStudioBtn').addEventListener('click', () => {
                    this.openStudio();
                });
                
                document.getElementById('vocalCloseBtn').addEventListener('click', () => {
                    this.closeStudio();
                });
                
                // Record button
                document.getElementById('vocalRecordBtn').addEventListener('click', () => {
                    if (!this.isRecording) {
                        this.startRecording();
                    } else {
                        this.stopRecording();
                    }
                });
                
                // Close on escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && document.getElementById('vocalStudioOverlay').classList.contains('active')) {
                        this.closeStudio();
                    }
                });
            }
            
            async openStudio() {
                // Show legal agreement first
                const agreed = await this.showLegalAgreement();
                if (!agreed) return;
                
                // Initialize audio
                await this.initializeAudio();
                
                // Show studio
                document.getElementById('vocalStudioOverlay').classList.add('active');
                
                // Start meters animation
                this.animateMeters();
            }
            
            closeStudio() {
                document.getElementById('vocalStudioOverlay').classList.remove('active');
                
                // Stop recording if active
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                // Clean up audio
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
            }
            
            async showLegalAgreement() {
                return new Promise((resolve) => {
                    // Create modal
                    const modal = document.createElement('div');
                    modal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.95);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 4000;
                        backdrop-filter: blur(10px);
                    `;
                    
                    modal.innerHTML = `
                        <div style="width: 90%; max-width: 600px; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 30px;">
                            <h2 style="font-size: 18px; margin-bottom: 20px; color: #ff0066; text-align: center; text-transform: uppercase; letter-spacing: 2px;">Recording Agreement</h2>
                            <div style="height: 200px; overflow-y: auto; background: #000; border: 1px solid #333; padding: 20px; border-radius: 4px; margin-bottom: 20px; font-size: 12px; line-height: 1.6; color: #ccc;">
                                <h3>AI VOCAL PROCESSING & RECORDING RELEASE</h3>
                                <br>
                                <p><strong>GRANT OF RIGHTS:</strong> You grant Sound Factory NYC unlimited rights to record, process, manipulate, and use your voice with AI technology including but not limited to:</p>
                                <ul style="margin: 10px 0; padding-left: 20px;">
                                    <li>Auto-tune and pitch correction</li>
                                    <li>Harmony generation</li>
                                    <li>Voice synthesis and cloning</li>
                                    <li>Tempo and key matching</li>
                                    <li>Sample creation and triggering</li>
                                    <li>Real-time effects processing</li>
                                </ul>
                                <p><strong>NO COMPENSATION:</strong> No royalties or payments will be provided.</p>
                                <p><strong>AGE REQUIREMENT:</strong> You must be 18 or older.</p>
                            </div>
                            <label style="display: flex; align-items: center; margin-bottom: 15px; cursor: pointer;">
                                <input type="checkbox" id="vocalAgeCheck" style="width: 16px; height: 16px; margin-right: 10px;">
                                <span>I am 18 years or older</span>
                            </label>
                            <label style="display: flex; align-items: center; margin-bottom: 15px; cursor: pointer;">
                                <input type="checkbox" id="vocalTermsCheck" style="width: 16px; height: 16px; margin-right: 10px;">
                                <span>I agree to all terms</span>
                            </label>
                            <div style="display: flex; gap: 10px;">
                                <button id="vocalDeclineBtn" style="flex: 1; padding: 12px; background: #333; color: #fff; border: none; border-radius: 4px; font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; cursor: pointer;">Decline</button>
                                <button id="vocalAgreeBtn" style="flex: 1; padding: 12px; background: #ff0066; color: #fff; border: none; border-radius: 4px; font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; cursor: pointer; opacity: 0.5;" disabled>Agree & Continue</button>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    
                    const ageCheck = modal.querySelector('#vocalAgeCheck');
                    const termsCheck = modal.querySelector('#vocalTermsCheck');
                    const agreeBtn = modal.querySelector('#vocalAgreeBtn');
                    const declineBtn = modal.querySelector('#vocalDeclineBtn');
                    
                    const checkAgreement = () => {
                        const canAgree = ageCheck.checked && termsCheck.checked;
                        agreeBtn.disabled = !canAgree;
                        agreeBtn.style.opacity = canAgree ? '1' : '0.5';
                    };
                    
                    ageCheck.addEventListener('change', checkAgreement);
                    termsCheck.addEventListener('change', checkAgreement);
                    
                    agreeBtn.addEventListener('click', () => {
                        modal.remove();
                        resolve(true);
                    });
                    
                    declineBtn.addEventListener('click', () => {
                        modal.remove();
                        resolve(false);
                    });
                });
            }
            
            async initializeAudio() {
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    this.audioContext = new AudioContext({ sampleRate: 48000 });
                    this.analyser = this.audioContext.createAnalyser();
                    const source = this.audioContext.createMediaStreamSource(this.stream);
                    source.connect(this.analyser);
                    
                    this.mediaRecorder = new MediaRecorder(this.stream);
                    this.mediaRecorder.ondataavailable = e => this.audioChunks.push(e.data);
                    this.mediaRecorder.onstop = () => this.processRecording();
                    
                } catch (error) {
                    console.error('Microphone access denied:', error);
                    alert('Microphone access is required for the AI Vocal Studio. Please allow microphone access and try again.');
                }
            }
            
            setupCanvas() {
                this.canvas = document.getElementById('vocalWaveformCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                const resizeCanvas = () => {
                    if (this.canvas) {
                        this.canvas.width = this.canvas.offsetWidth;
                        this.canvas.height = this.canvas.offsetHeight;
                    }
                };
                
                window.addEventListener('resize', resizeCanvas);
                setTimeout(resizeCanvas, 100); // Delay to ensure canvas is rendered
            }
            
            startRecording() {
                if (!this.mediaRecorder) {
                    alert('Audio system not initialized. Please close and reopen the studio.');
                    return;
                }
                
                this.audioChunks = [];
                this.mediaRecorder.start();
                this.isRecording = true;
                this.startTime = Date.now();
                
                document.getElementById('vocalRecordBtn').classList.add('recording');
                document.getElementById('vocalRecordIndicator').classList.add('active');
                document.getElementById('vocalWaveformOverlay').style.display = 'none';
                document.getElementById('vocalAiStatus').textContent = 'PROCESSING';
                document.getElementById('vocalAiStatus').className = 'vocal-ai-status processing';
                
                this.timerInterval = setInterval(() => this.updateTimer(), 100);
                
                // Auto-stop after 5 minutes
                setTimeout(() => {
                    if (this.isRecording) {
                        this.stopRecording();
                    }
                }, 300000);
            }
            
            stopRecording() {
                if (!this.isRecording) return;
                
                this.mediaRecorder.stop();
                this.isRecording = false;
                
                document.getElementById('vocalRecordBtn').classList.remove('recording');
                document.getElementById('vocalRecordIndicator').classList.remove('active');
                
                clearInterval(this.timerInterval);
            }
            
            updateTimer() {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const remaining = 300 - elapsed; // 5 minutes max
                
                if (remaining <= 0) {
                    this.stopRecording();
                    return;
                }
                
                const formatTime = (seconds) => {
                    const min = Math.floor(seconds / 60);
                    const sec = seconds % 60;
                    return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
                };
                
                document.getElementById('vocalElapsed').textContent = formatTime(elapsed);
                document.getElementById('vocalRemaining').textContent = formatTime(remaining);
            }
            
            async processRecording() {
                const blob = new Blob(this.audioChunks, { type: 'audio/wav' });
                
                // Simulate AI processing
                document.getElementById('vocalAiStatus').textContent = 'AI PROCESSING...';
                document.getElementById('vocalAiStatus').className = 'vocal-ai-status processing';
                
                // Simulate processing time
                setTimeout(() => {
                    // Update detected values
                    const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                    const modes = ['MAJ', 'MIN'];
                    const randomKey = keys[Math.floor(Math.random() * keys.length)];
                    const randomMode = modes[Math.floor(Math.random() * modes.length)];
                    document.getElementById('vocalDetectedKey').textContent = `${randomKey} ${randomMode}`;
                    
                    const bpm = 120 + Math.floor(Math.random() * 40);
                    document.getElementById('vocalDetectedBPM').textContent = `${bpm} BPM`;
                    
                    document.getElementById('vocalAiStatus').textContent = 'PROCESSING COMPLETE - READY TO SEND';
                    document.getElementById('vocalAiStatus').className = 'vocal-ai-status ready';
                    
                    // Create download link (simulated processed audio)
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `sf_vocal_${Date.now()}.wav`;
                    
                    // Show notification
                    showNotification('🎤 Vocal processed and ready!', '#00ff88');
                    
                    // Auto-download processed file
                    setTimeout(() => {
                        a.click();
                        URL.revokeObjectURL(url);
                    }, 1000);
                    
                }, 3000);
            }
            
            animateMeters() {
                if (!this.analyser || !document.getElementById('vocalStudioOverlay').classList.contains('active')) {
                    // Stop animation if studio is closed
                    setTimeout(() => this.animateMeters(), 100);
                    return;
                }
                
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteFrequencyData(dataArray);
                
                const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                const percentage = (average / 255) * 100;
                
                document.getElementById('vocalInputMeter').style.width = percentage + '%';
                document.getElementById('vocalOutputMeter').style.width = (percentage * 0.8) + '%';
                
                // Draw waveform
                if (this.isRecording && this.canvas && this.ctx) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.beginPath();
                    
                    const sliceWidth = this.canvas.width / dataArray.length;
                    let x = 0;
                    
                    for (let i = 0; i < dataArray.length; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * this.canvas.height / 2;
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    this.ctx.stroke();
                }
                
                requestAnimationFrame(() => this.animateMeters());
            }
        }

        // Toggle vocal switches
        function toggleVocalSwitch(element) {
            element.classList.toggle('active');
        }

        // Initialize AI Vocal Studio
        document.addEventListener('DOMContentLoaded', () => {
            window.aiVocalStudio = new AIVocalStudio();
        });

        // ALAMS (AI Live Audio Manipulation System)
        class ALAMSSystem {
            constructor() {
                this.isCapturing = false;
                this.captureStartTime = null;
                this.captureTimer = null;
                this.audioChunks = [];
                this.mediaRecorder = null;
                this.stream = null;
                this.currentTrack = null;
                this.knobValues = {
                    track: 0,
                    keyboard: 50,
                    effects: 50,
                    mix: 50,
                    arrangement: 0
                };
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Open/Close ALAMS
                document.getElementById('alamsBtn').addEventListener('click', () => {
                    this.openALAMS();
                });
                
                document.getElementById('alamsCloseBtn').addEventListener('click', () => {
                    this.closeALAMS();
                });
                
                // Capture button
                document.getElementById('alamsCaptureSection').addEventListener('click', () => {
                    if (!this.isCapturing) {
                        this.startCapture();
                    } else {
                        this.stopCapture();
                    }
                });
                
                // Knob interactions
                this.setupKnobControls();
                
                // Export button
                document.getElementById('alamsExportBtn').addEventListener('click', () => {
                    this.exportTrack();
                });
                
                // Close on escape
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && document.getElementById('alamsOverlay').classList.contains('active')) {
                        this.closeALAMS();
                    }
                });
            }
            
            async openALAMS() {
                // Check SMS verification
                if (!window.smsGate || !window.smsGate.isVerified) {
                    showNotification('🔐 Please verify your phone first', '#ff6b6b');
                    return;
                }
                
                // Initialize audio
                await this.initializeAudio();
                
                // Show ALAMS
                document.getElementById('alamsOverlay').classList.add('active');
                
                // Update status
                document.getElementById('alamsAudioStatus').classList.add('active');
                document.getElementById('alamsAiStatus').classList.add('active');
            }
            
            closeALAMS() {
                document.getElementById('alamsOverlay').classList.remove('active');
                
                // Stop capture if active
                if (this.isCapturing) {
                    this.stopCapture();
                }
                
                // Clean up audio
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
            }
            
            async initializeAudio() {
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    this.mediaRecorder = new MediaRecorder(this.stream);
                    this.mediaRecorder.ondataavailable = e => this.audioChunks.push(e.data);
                    this.mediaRecorder.onstop = () => this.processAudio();
                    
                } catch (error) {
                    console.error('Audio access denied:', error);
                    showNotification('🎤 Microphone access required', '#ff6b6b');
                }
            }
            
            startCapture() {
                if (!this.mediaRecorder) {
                    showNotification('🎤 Audio system not ready', '#ff6b6b');
                    return;
                }
                
                this.audioChunks = [];
                this.mediaRecorder.start();
                this.isCapturing = true;
                this.captureStartTime = Date.now();
                
                // Update UI
                document.getElementById('alamsCaptureSection').classList.add('recording');
                document.getElementById('alamsCaptureText').textContent = 'RECORDING...';
                document.getElementById('alamsProcessingStatus').classList.add('active');
                
                // Start timer
                this.captureTimer = setInterval(() => {
                    this.updateCaptureTimer();
                }, 100);
                
                // Auto-stop after 20 seconds
                setTimeout(() => {
                    if (this.isCapturing) {
                        this.stopCapture();
                    }
                }, 20000);
            }
            
            stopCapture() {
                if (!this.isCapturing) return;
                
                this.mediaRecorder.stop();
                this.isCapturing = false;
                
                // Update UI
                document.getElementById('alamsCaptureSection').classList.remove('recording');
                document.getElementById('alamsCaptureText').textContent = 'PROCESSING...';
                
                clearInterval(this.captureTimer);
            }
            
            updateCaptureTimer() {
                const elapsed = (Date.now() - this.captureStartTime) / 1000;
                const remaining = 20 - elapsed;
                
                if (remaining <= 0) {
                    this.stopCapture();
                    return;
                }
                
                const formatTime = (seconds) => {
                    const sec = Math.floor(seconds);
                    return `${Math.floor(sec / 60)}:${String(sec % 60).padStart(2, '0')}`;
                };
                
                document.getElementById('alamsCaptureTimer').textContent = formatTime(elapsed);
                document.getElementById('alamsTimerDisplay').textContent = formatTime(remaining);
            }
            
            async processAudio() {
                const blob = new Blob(this.audioChunks, { type: 'audio/wav' });
                
                // Simulate AI processing
                document.getElementById('alamsCaptureText').textContent = 'AI PROCESSING...';
                
                // Simulate processing time (2-3 seconds)
                setTimeout(() => {
                    // Generate multiple track variations
                    this.generateTrackVariations(blob);
                    
                    // Update UI
                    document.getElementById('alamsCaptureText').textContent = 'READY TO MANIPULATE';
                    document.getElementById('alamsReadyStatus').classList.add('active');
                    document.getElementById('alamsExportBtn').disabled = false;
                    
                    // Show success notification
                    showNotification('🎵 AI generated 5 track variations!', '#00ff88');
                    
                    // Reset timer
                    document.getElementById('alamsCaptureTimer').textContent = '00:00';
                    document.getElementById('alamsTimerDisplay').textContent = '00:00';
                    
                }, 2500);
            }
            
            generateTrackVariations(originalBlob) {
                // Simulate AI track generation
                this.currentTrack = {
                    original: originalBlob,
                    variations: [
                        { name: 'Electronic', style: 'edm', bpm: 128 },
                        { name: 'Hip-Hop', style: 'hiphop', bpm: 95 },
                        { name: 'House', style: 'house', bpm: 124 },
                        { name: 'Ambient', style: 'ambient', bpm: 85 },
                        { name: 'Trap', style: 'trap', bpm: 140 }
                    ],
                    currentVariation: 0
                };
                
                // Update metronome
                this.updateMetronome();
            }
            
            setupKnobControls() {
                const knobs = document.querySelectorAll('.alams-knob');
                
                knobs.forEach(knob => {
                    let isDragging = false;
                    let startY = 0;
                    let startValue = 0;
                    
                    knob.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        startY = e.clientY;
                        startValue = this.knobValues[knob.dataset.knob] || 50;
                        e.preventDefault();
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        
                        const deltaY = startY - e.clientY;
                        const sensitivity = 0.5;
                        let newValue = startValue + (deltaY * sensitivity);
                        
                        // Clamp value
                        newValue = Math.max(0, Math.min(100, newValue));
                        
                        this.updateKnob(knob.dataset.knob, newValue);
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                    
                    // Touch support
                    knob.addEventListener('touchstart', (e) => {
                        isDragging = true;
                        startY = e.touches[0].clientY;
                        startValue = this.knobValues[knob.dataset.knob] || 50;
                        e.preventDefault();
                    });
                    
                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging) return;
                        
                        const deltaY = startY - e.touches[0].clientY;
                        const sensitivity = 0.5;
                        let newValue = startValue + (deltaY * sensitivity);
                        
                        newValue = Math.max(0, Math.min(100, newValue));
                        this.updateKnob(knob.dataset.knob, newValue);
                    });
                    
                    document.addEventListener('touchend', () => {
                        isDragging = false;
                    });
                });
            }
            
            updateKnob(knobType, value) {
                this.knobValues[knobType] = value;
                
                // Update visual indicator
                const knob = document.querySelector(`[data-knob="${knobType}"]`);
                const indicator = knob.querySelector('.alams-knob-indicator');
                const rotation = (value / 100) * 180 - 90; // -90 to +90 degrees
                indicator.style.transform = `rotate(${rotation}deg)`;
                
                // Update LED ring
                const ledRing = knob.querySelector('.alams-led-ring');
                const percentage = value;
                ledRing.style.background = `conic-gradient(from 0deg, #00ff88 0%, #00ff88 ${percentage}%, transparent ${percentage}%)`;
                
                // Handle specific knob actions
                switch (knobType) {
                    case 'track':
                        this.switchTrackVariation(Math.floor((value / 100) * 4)); // 0-4 tracks
                        break;
                    case 'keyboard':
                        this.updateKeyboardSound(value);
                        break;
                    case 'effects':
                        this.updateEffects(value);
                        break;
                    case 'mix':
                        this.updateMixBalance(value);
                        break;
                    case 'arrangement':
                        this.updateArrangement(value);
                        break;
                }
            }
            
            switchTrackVariation(index) {
                if (!this.currentTrack) return;
                
                this.currentTrack.currentVariation = index;
                const variation = this.currentTrack.variations[index];
                
                // Update metronome
                this.updateMetronome();
                
                // Show notification
                showNotification(`🎵 Switched to ${variation.name}`, '#667eea');
            }
            
            updateKeyboardSound(value) {
                // Simulate keyboard sound changes
                const intensity = Math.floor((value / 100) * 5) + 1;
                console.log(`Keyboard intensity: ${intensity}/5`);
            }
            
            updateEffects(value) {
                // Simulate effects processing
                const effectLevel = Math.floor((value / 100) * 10) + 1;
                console.log(`Effects level: ${effectLevel}/10`);
            }
            
            updateMixBalance(value) {
                // Simulate mix balance
                const balance = (value - 50) / 50; // -1 to +1
                console.log(`Mix balance: ${balance.toFixed(2)}`);
            }
            
            updateArrangement(value) {
                // Simulate arrangement changes
                const sections = ['Intro', 'Verse', 'Chorus', 'Bridge', 'Outro'];
                const sectionIndex = Math.floor((value / 100) * (sections.length - 1));
                console.log(`Arrangement: ${sections[sectionIndex]}`);
            }
            
            updateMetronome() {
                if (!this.currentTrack) return;
                
                const variation = this.currentTrack.variations[this.currentTrack.currentVariation];
                document.getElementById('alamsMetronome').innerHTML = `<div>${variation.bpm} BPM</div>`;
            }
            
            exportTrack() {
                if (!this.currentTrack) {
                    showNotification('🎵 No track to export', '#ff6b6b');
                    return;
                }
                
                // Simulate export process
                document.getElementById('alamsExportBtn').textContent = 'SENDING...';
                document.getElementById('alamsExportBtn').disabled = true;
                
                setTimeout(() => {
                    // Create download link
                    const variation = this.currentTrack.variations[this.currentTrack.currentVariation];
                    const url = URL.createObjectURL(this.currentTrack.original);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `SF_ALAMS_${variation.name}_${Date.now()}.wav`;
                    
                    // Auto-download
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    // Reset button
                    document.getElementById('alamsExportBtn').textContent = 'SEND TO DJ';
                    document.getElementById('alamsExportBtn').disabled = false;
                    
                    // Show success
                    showNotification('🎵 Track sent to DJ! Check downloads.', '#00ff88');
                    
                    // Close ALAMS after successful export
                    setTimeout(() => {
                        this.closeALAMS();
                    }, 2000);
                    
                }, 1500);
            }
        }

        // Initialize ALAMS
        document.addEventListener('DOMContentLoaded', () => {
            window.alamsSystem = new ALAMSSystem();
        });
    </script>
        <script>
            // Fallbacks for missing images (flyer and logo)
            (function addImageFallbacks(){
                        function flyerPlaceholder() {
                                const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="630" viewBox="0 0 1200 630">
    <defs>
        <linearGradient id="g" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0%" stop-color="#0a0a0a"/>
            <stop offset="100%" stop-color="#1a1a1a"/>
        </linearGradient>
    </defs>
    <rect width="1200" height="630" fill="url(#g)"/>
    <text x="50%" y="44%" fill="#ffffff" font-family="Inter, Helvetica, Arial, sans-serif" font-size="72" font-weight="800" text-anchor="middle">SOUND FACTORY</text>
    <text x="50%" y="58%" fill="#ff1a78" font-family="Inter, Helvetica, Arial, sans-serif" font-size="56" font-weight="900" text-anchor="middle">SÉANCE • NOV 1</text>
    <text x="50%" y="72%" fill="#cccccc" font-family="Inter, Helvetica, Arial, sans-serif" font-size="28" font-weight="700" text-anchor="middle">Tap for Tickets</text>
    <rect x="350" y="380" width="500" height="4" fill="#ff1a78" opacity="0.6"/>
</svg>`;
                                return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
                        }
                        function logoPlaceholder() {
                                const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128" viewBox="0 0 128 128">
    <defs>
        <linearGradient id="lg" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0%" stop-color="#0b0b0b"/>
            <stop offset="100%" stop-color="#1c1c1c"/>
        </linearGradient>
    </defs>
    <rect width="128" height="128" rx="16" fill="url(#lg)"/>
    <text x="50%" y="56%" fill="#ffffff" font-family="Inter, Helvetica, Arial, sans-serif" font-size="44" font-weight="900" text-anchor="middle">SF</text>
</svg>`;
                                return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
                        }
                        // Replace broken flyer/logo images added now
                        function attachListeners(scope=document) {
                            scope.querySelectorAll('img[src*="seance-flyer.jpg"]').forEach(img => {
                                img.addEventListener('error', () => { img.src = flyerPlaceholder(); }, { once: true, capture: false });
                            });
                            scope.querySelectorAll('img[src*="sf-logo.png"]').forEach(img => {
                                img.addEventListener('error', () => { img.src = logoPlaceholder(); }, { once: true, capture: false });
                            });
                        }
                        attachListeners(document);
                        // Global capture handler for dynamically assigned image src
                        document.addEventListener('error', (e) => {
                            const t = e.target;
                            if (t && t.tagName === 'IMG') {
                                if ((t.src||'').indexOf('seance-flyer.jpg') !== -1) t.src = flyerPlaceholder();
                                if ((t.src||'').indexOf('sf-logo.png') !== -1) t.src = logoPlaceholder();
                            }
                        }, true);
                        // Ensure CSS background logo shows a fallback
                        const logoEls = document.querySelectorAll('.onboard-logo');
                        logoEls.forEach(el => {
                            el.style.backgroundImage = `url(${logoPlaceholder()})`;
                            el.style.backgroundSize = 'contain';
                            el.style.backgroundPosition = 'center';
                            el.style.backgroundRepeat = 'no-repeat';
                        });
                })();
        </script>
        <script>
            // Séance Easter Eggs: Konami code + triple-tap logo → floating flyers and theme
            (function(){
                function ensureSeanceStyles(){
                    if (document.getElementById('seanceStyles')) return;
                    const style = document.createElement('style');
                    style.id = 'seanceStyles';
                    style.textContent = `
                        .seance-mode { animation: seanceTransform 3s ease-out; }
                        .seance-mode .floor-svg { filter: hue-rotate(240deg) saturate(1.5); }
                        .seance-mode .enhanced-pin { animation: ghostFloat 2s ease-out infinite; }
                        @keyframes seanceTransform {
                            0% { filter: none; }
                            50% { filter: hue-rotate(240deg) blur(2px); }
                            100% { filter: none; }
                        }
                        @keyframes ghostFloat {
                            0%, 100% { transform: translateY(0) rotate(-45deg); }
                            50% { transform: translateY(-5px) rotate(-45deg); }
                        }
                        @keyframes flyerFloat {
                            0% { transform: translate(-50%, -50%) scale(0.9) rotate(0deg); opacity: 0; }
                            10% { opacity: .85; }
                            50% { transform: translate(-50%, -62%) scale(1) rotate(2deg); opacity: 1; }
                            100% { transform: translate(-50%, -78%) scale(1.05) rotate(-2deg); opacity: 0; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                function createFloatingFlyer(){
                    ensureSeanceStyles();
                    const el = document.createElement('div');
                    const size = 120 + Math.random()*80; // 120-200px
                    const left = 10 + Math.random()*80; // percent
                    const delay = Math.random()*600; // small stagger
                    el.style.cssText = `
                        position: fixed; left: ${left}%; top: 65%; transform: translate(-50%, -50%);
                        width: ${size}px; height: auto; z-index: 4500; pointer-events: none;
                        filter: drop-shadow(0 10px 22px rgba(0,0,0,.45)); opacity: 0;
                        animation: flyerFloat ${5 + Math.random()*3}s ease-out ${delay}ms forwards;
                    `;
                    const a = document.createElement('a');
                    a.href = (typeof TICKET_URL !== 'undefined' ? TICKET_URL : '#');
                    a.target = '_blank'; a.rel = 'noopener'; a.style.cssText = 'pointer-events:auto; display:block;';
                    const img = document.createElement('img');
                    img.src = 'seance-flyer.jpg';
                    img.alt = 'Sound Factory Séance • 11.1.2025';
                    img.style.cssText = 'width:100%; height:auto; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:#0a0a0a;';
                    a.appendChild(img);
                    el.appendChild(a);
                    document.body.appendChild(el);
                    // Auto-remove after animation
                    setTimeout(()=>{ el.remove(); }, 9000);
                    return el;
                }

                function showFloatingFlyer(){
                    ensureSeanceStyles();
                    // If an overlay is already open, refresh the animation
                    const existing = document.getElementById('seanceFlyerOverlay');
                    if (existing) { existing.remove(); }
                    const overlay = document.createElement('div');
                    overlay.id = 'seanceFlyerOverlay';
                    overlay.style.cssText = `
                        position: fixed; inset: 0; z-index: 4600; display: grid; place-items: center;
                        background: rgba(0,0,0,0.75); backdrop-filter: blur(6px);
                    `;
                    const card = document.createElement('div');
                    card.style.cssText = `
                        position: relative; width: min(92vw, 520px); border-radius: 14px; overflow: hidden;
                        border: 1px solid rgba(255,255,255,0.12); box-shadow: 0 18px 50px rgba(0,0,0,0.5);
                        transform: translateY(10px); opacity: 0; transition: all .25s ease;
                        background: rgba(10,10,10,0.85); backdrop-filter: blur(8px);
                    `;
                    const close = document.createElement('button');
                    close.textContent = '×';
                    close.setAttribute('aria-label','Close');
                    close.style.cssText = `
                        position:absolute; top:8px; right:8px; width:30px; height:30px; border-radius:50%;
                        border:1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.5); color:#fff; font-size:18px; cursor:pointer;
                    `;
                    const a = document.createElement('a');
                    a.href = (typeof TICKET_URL !== 'undefined' ? TICKET_URL : '#');
                    a.target = '_blank'; a.rel = 'noopener'; a.style.cssText = 'display:block;';
                    const img = document.createElement('img');
                    img.src = 'seance-flyer.jpg';
                    img.alt = 'Sound Factory Séance • 11.1.2025';
                    img.style.cssText = 'width:100%; height:auto; display:block; border-radius:12px;';
                    a.appendChild(img);
                    card.appendChild(close);
                    card.appendChild(a);
                    overlay.appendChild(card);
                    document.body.appendChild(overlay);
                    // Animate in
                    requestAnimationFrame(()=>{ card.style.transform = 'translateY(0)'; card.style.opacity = '1'; });
                    // Close events
                    overlay.addEventListener('click', (e)=>{ if (e.target === overlay) overlay.remove(); });
                    close.addEventListener('click', ()=> overlay.remove());
                    return overlay;
                }

                function triggerSeanceMode(){
                    ensureSeanceStyles();
                    document.body.classList.add('seance-mode');
                    // Release a few floating flyers
                    for (let i=0; i<5; i++) setTimeout(createFloatingFlyer, i*200);
                }

                function addSeanceEasterEggs(){
                    // Konami code → theme + flyers
                    let konamiCode = [];
                    const sequence = ['ArrowUp','ArrowUp','ArrowDown','ArrowDown','ArrowLeft','ArrowRight','ArrowLeft','ArrowRight','b','a'];
                    document.addEventListener('keydown', (e) => {
                        konamiCode.push(e.key);
                        konamiCode = konamiCode.slice(-sequence.length);
                        if (konamiCode.join(',') === sequence.join(',')) {
                            triggerSeanceMode();
                        }
                    });
                    // Triple-tap on wordmark → centered flyer
                    const wm = document.querySelector('.brand-wordmark');
                    if (wm) {
                        let tapCount = 0; let tapTimer;
                        wm.addEventListener('click', () => {
                            tapCount++;
                            clearTimeout(tapTimer);
                            if (tapCount === 3) { showFloatingFlyer(); tapCount = 0; }
                            tapTimer = setTimeout(()=>{ tapCount = 0; }, 500);
                        });
                    }
                }
                // Expose minimal API (optional)
                window.createFloatingFlyer = createFloatingFlyer;
                window.showFloatingFlyer = showFloatingFlyer;
                window.triggerSeanceMode = triggerSeanceMode;
                window.addSeanceEasterEggs = addSeanceEasterEggs;

                document.addEventListener('DOMContentLoaded', addSeanceEasterEggs);
            })();
        </script>

        <!-- Draggable and Resizable Stage + Draggable Buttons -->
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                // Make both stage pieces and disco ball draggable and resizable
                const stages = [
                    document.getElementById('draggableStage1'),
                    document.getElementById('draggableStage2'),
                    document.getElementById('discoBall')
                ];

                stages.forEach((stage, index) => {
                    if (!stage) return;

                    let isDragging = false;
                    let isResizing = false;
                    let startX, startY, initialX, initialY, initialWidth, initialHeight;

                    // Mouse events
                    stage.addEventListener('mousedown', startDrag);
                    document.addEventListener('mousemove', drag);
                    document.addEventListener('mouseup', endDrag);

                    // Touch events for mobile
                    stage.addEventListener('touchstart', startDrag, { passive: false });
                    document.addEventListener('touchmove', drag, { passive: false });
                    document.addEventListener('touchend', endDrag);

                    function startDrag(e) {
                        const rect = e.target.getBoundingClientRect();
                        const x = e.clientX || e.touches[0].clientX;
                        const y = e.clientY || e.touches[0].clientY;
                        
                        // Check if clicking near edge for resize
                        const edgeThreshold = 10;
                        const isNearRightEdge = x > rect.right - edgeThreshold;
                        const isNearBottomEdge = y > rect.bottom - edgeThreshold;
                        
                        if (isNearRightEdge || isNearBottomEdge) {
                            isResizing = true;
                            stage.style.cursor = 'nw-resize';
                        } else {
                            isDragging = true;
                            stage.style.cursor = 'grabbing';
                        }
                        
                        startX = x;
                        startY = y;
                        
                        // Get current transform values
                        const transform = stage.getAttribute('transform') || '';
                        const translateMatch = transform.match(/translate\(([^,]+),([^)]+)\)/);
                        initialX = translateMatch ? parseFloat(translateMatch[1]) : 0;
                        initialY = translateMatch ? parseFloat(translateMatch[2]) : 0;
                        
                        // Get current size
                        const rects = stage.querySelectorAll('rect');
                        if (rects[0]) {
                            initialWidth = parseFloat(rects[0].getAttribute('width'));
                            initialHeight = parseFloat(rects[0].getAttribute('height'));
                        }
                        
                        e.preventDefault();
                    }

                    function drag(e) {
                        if (!isDragging && !isResizing) return;
                        
                        const clientX = e.clientX || e.touches[0].clientX;
                        const clientY = e.clientY || e.touches[0].clientY;
                        
                        const deltaX = clientX - startX;
                        const deltaY = clientY - startY;
                        
                        if (isDragging) {
                            const newX = initialX + deltaX;
                            const newY = initialY + deltaY;
                            stage.setAttribute('transform', `translate(${newX}, ${newY})`);
                        } else if (isResizing) {
                            const newWidth = Math.max(20, initialWidth + deltaX);
                            const newHeight = Math.max(20, initialHeight + deltaY);
                            
                            // Update all rects in the stage
                            const rects = stage.querySelectorAll('rect');
                            rects.forEach((rect, i) => {
                                if (i === 0) {
                                    rect.setAttribute('width', newWidth);
                                    rect.setAttribute('height', newHeight);
                                } else {
                                    rect.setAttribute('width', newWidth - 10);
                                    rect.setAttribute('height', newHeight - 10);
                                }
                            });
                            
                            // Update lights position
                            const lights = stage.querySelectorAll('circle');
                            const centerX = 150 + (newWidth / 2);
                            lights.forEach((light, i) => {
                                light.setAttribute('cx', centerX);
                            });
                        }
                        
                        e.preventDefault();
                    }

                    function endDrag() {
                        isDragging = false;
                        isResizing = false;
                        stage.style.cursor = 'move';
                    }

                    // Add visual feedback when hovering
                    stage.addEventListener('mouseenter', function() {
                        if (!isDragging && !isResizing) {
                            stage.style.cursor = 'move';
                            stage.style.filter = 'brightness(1.2)';
                        }
                    });

                    stage.addEventListener('mouseleave', function() {
                        if (!isDragging && !isResizing) {
                            stage.style.cursor = 'default';
                            stage.style.filter = 'none';
                        }
                    });
                });

                // Make all bottom buttons draggable
                const draggableButtons = [
                    'aiStudioBtn',
                    'aiSamplerBtn',
                    'liveShareBtn',
                    'accountBtn',
                    'acctUpload',
                    'acctVerify',
                    'acctClose',
                    'onAddPhoto',
                    'onGoDrop',
                    'onVerify',
                    'onFind',
                    'customSubmit',
                    'sfChatSend',
                    'vocalCloseBtn',
                    'pcShare',
                    'pcLike',
                    'pcComment',
                    'pcDrink',
                    'pcTicket'
                ];


                // ONLY make specific interactive elements draggable (exclude ALL background SVG elements)
                const specificDraggableElements = [
                    'aiStudioBtn', 'aiSamplerBtn', 'liveShareBtn', 'accountBtn', 'acctUpload', 'acctVerify', 'acctClose',
                    'onAddPhoto', 'onGoDrop', 'onVerify', 'onFind', 'customSubmit', 'sfChatSend', 'vocalCloseBtn',
                    'pcShare', 'pcLike', 'pcComment', 'pcDrink', 'pcTicket', 'mainGridButton', 'discoBall', 
                    'draggableStage1', 'draggableStage2', 'sf-chat-system'
                ];
                
                // Add these specific elements to draggable list
                specificDraggableElements.forEach(elementId => {
                    if (!draggableButtons.includes(elementId)) {
                        draggableButtons.push(elementId);
                    }
                });

                // Add specific button classes that should be draggable
                const draggableButtonClasses = [
                    '.ai-studio-btn', '.ai-sampler-btn', '.live-share-btn', '.account-btn', '.on-btn', 
                    '.custom-submit-btn', '.sf-send-btn', '.vocal-close-btn', '.profile-btn', '.pin-action-btn',
                    '.header-link', '.mode-btn', '.floor-btn', '.pin', '.character'
                ];
                
                draggableButtonClasses.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(element => {
                        if (element.id && !draggableButtons.includes(element.id)) {
                            draggableButtons.push(element.id);
                        }
                    });
                });

                // Explicitly exclude background SVG elements from being draggable
                const backgroundElements = document.querySelectorAll('svg.floor-svg, svg.floor-svg rect, svg.floor-svg g, svg.floor-svg line, svg.floor-svg path, svg.floor-svg circle, svg.floor-svg text');
                backgroundElements.forEach(element => {
                    if (element.id) {
                        const index = draggableButtons.indexOf(element.id);
                        if (index > -1) {
                            draggableButtons.splice(index, 1);
                        }
                    }
                });

                draggableButtons.forEach(buttonId => {
                    const button = document.getElementById(buttonId) || document.querySelector(`.${buttonId}`);
                    if (!button) return;

                    let isDragging = false;
                    let isResizing = false;
                    let startX, startY, initialX, initialY, initialWidth, initialHeight;

                    button.addEventListener('mousedown', startButtonDrag);
                    document.addEventListener('mousemove', dragButton);
                    document.addEventListener('mouseup', endButtonDrag);

                    button.addEventListener('touchstart', startButtonDrag, { passive: false });
                    document.addEventListener('touchmove', dragButton, { passive: false });
                    document.addEventListener('touchend', endButtonDrag);

                    function startButtonDrag(e) {
                        const rect = button.getBoundingClientRect();
                        const x = e.clientX || e.touches[0].clientX;
                        const y = e.clientY || e.touches[0].clientY;
                        
                        // Check if clicking near edge for resize
                        const edgeThreshold = 10;
                        const isNearRightEdge = x > rect.right - edgeThreshold;
                        const isNearBottomEdge = y > rect.bottom - edgeThreshold;
                        const isNearLeftEdge = x < rect.left + edgeThreshold;
                        const isNearTopEdge = y < rect.top + edgeThreshold;
                        
                        if (isNearRightEdge || isNearBottomEdge || isNearLeftEdge || isNearTopEdge) {
                            isResizing = true;
                            button.style.cursor = 'nw-resize';
                        } else {
                            isDragging = true;
                            button.style.cursor = 'grabbing';
                        }
                        
                        const clientX = e.clientX || e.touches[0].clientX;
                        const clientY = e.clientY || e.touches[0].clientY;
                        
                        startX = clientX;
                        startY = clientY;
                        
                        initialX = rect.left;
                        initialY = rect.top;
                        initialWidth = rect.width;
                        initialHeight = rect.height;
                        
                        e.preventDefault();
                    }

                    function dragButton(e) {
                        if (!isDragging && !isResizing) return;
                        
                        const clientX = e.clientX || e.touches[0].clientX;
                        const clientY = e.clientY || e.touches[0].clientY;
                        
                        const deltaX = clientX - startX;
                        const deltaY = clientY - startY;
                        
                        if (isDragging) {
                            const newX = initialX + deltaX;
                            const newY = initialY + deltaY;
                            
                            button.style.position = 'fixed';
                            button.style.left = newX + 'px';
                            button.style.top = newY + 'px';
                            button.style.right = 'auto';
                            button.style.bottom = 'auto';
                        } else if (isResizing) {
                            const newWidth = Math.max(20, initialWidth + deltaX);
                            const newHeight = Math.max(20, initialHeight + deltaY);
                            
                            button.style.width = newWidth + 'px';
                            button.style.height = newHeight + 'px';
                        }
                        
                        e.preventDefault();
                    }

                    function endButtonDrag() {
                        isDragging = false;
                        isResizing = false;
                        button.style.cursor = 'move';
                    }

                    button.addEventListener('mouseenter', function() {
                        if (!isDragging && !isResizing) {
                            button.style.cursor = 'move';
                        }
                    });

                    button.addEventListener('mouseleave', function() {
                        if (!isDragging && !isResizing) {
                            button.style.cursor = 'default';
                        }
                    });

                    // Add resize cursor on edge hover
                    button.addEventListener('mousemove', function(e) {
                        if (isDragging || isResizing) return;
                        
                        const rect = button.getBoundingClientRect();
                        const x = e.clientX;
                        const y = e.clientY;
                        
                        const edgeThreshold = 10;
                        const isNearRightEdge = x > rect.right - edgeThreshold;
                        const isNearBottomEdge = y > rect.bottom - edgeThreshold;
                        const isNearLeftEdge = x < rect.left + edgeThreshold;
                        const isNearTopEdge = y < rect.top + edgeThreshold;
                        
                        if (isNearRightEdge || isNearBottomEdge || isNearLeftEdge || isNearTopEdge) {
                            button.style.cursor = 'nw-resize';
                        } else {
                            button.style.cursor = 'move';
                        }
                    });
                });
            });
        </script>
</body>
<!-- Black Chat Widget: minimal, black UI with 4 style controls; WS-powered -->
<script src="js/black-chat-widget.js"></script>
</html>