---
// LEDDisplay.astro
// High-resolution LED display for live streaming with backend integration

export interface Props {
  rows?: number;
  cols?: number;
  pixelSize?: string;
  wsUrl?: string;
}

const { 
  rows = 200, 
  cols = 100, 
  pixelSize = '1fr',
  wsUrl = 'ws://localhost:8080'
} = Astro.props;
---

<div class="led-container">
  <div class="led-display" id="ledDisplay">
    <div 
      class="led-grid" 
      id="ledGrid"
      data-rows={rows}
      data-cols={cols}
      data-ws-url={wsUrl}
      style={`grid-template-columns: repeat(${cols}, ${pixelSize}); grid-template-rows: repeat(${rows}, ${pixelSize});`}
    >
      <!-- Pixels will be generated by JavaScript -->
    </div>
  </div>
  
  <!-- Control Panel (hidden by default) -->
  <div class="control-panel" id="controlPanel">
    <button class="control-btn" data-action="clear">Clear</button>
    <button class="control-btn" data-action="test">Test Pattern</button>
    <button class="control-btn" data-action="connect">Connect Live</button>
    <button class="control-btn" data-action="sound-factory">Sound Factory Mode</button>
  </div>
</div>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  .led-container {
    position: fixed;
    inset: 0;
    background: #000000;
    overflow: hidden;
    z-index: 5000;
  }

  .led-display {
    width: 100%;
    height: 100%;
    background: #000000;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  /* LED Grid */
  .led-grid {
    display: grid;
    gap: 0;
    width: 100%;
    height: 100%;
    background: #000000;
  }

  /* LED Pixel */
  .led-pixel {
    background: #000000;
    border: none;
    position: relative;
    aspect-ratio: 1/1;
    transition: background-color 0.05s ease;
  }

  /* LED States */
  .led-pixel.on { background: #00ff00; }
  .led-pixel.red { background: #ff0000; }
  .led-pixel.green { background: #00ff00; }
  .led-pixel.blue { background: #0099ff; }
  .led-pixel.yellow { background: #ffff00; }
  .led-pixel.purple { background: #9900ff; }
  .led-pixel.white { background: #ffffff; }
  .led-pixel.orange { background: #ff9900; }
  .led-pixel.pink { background: #ff00ff; }
  .led-pixel.cyan { background: #00ffff; }

  /* Sound Factory specific colors */
  .led-pixel.sound-factory-pink { background: #ff1a78; }
  .led-pixel.sound-factory-blue { background: #00ffff; }
  .led-pixel.sound-factory-gold { background: #ffd700; }

  /* Brightness levels */
  .led-pixel.dim { opacity: 0.3; }
  .led-pixel.medium { opacity: 0.6; }
  .led-pixel.bright { opacity: 1; }

  /* Control Panel */
  .control-panel {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    background: rgba(0, 0, 0, 0.9);
    padding: 10px;
    border-radius: 10px;
    border: 1px solid #333;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }

  .control-panel.active {
    opacity: 1;
    pointer-events: all;
  }

  .control-btn {
    background: #1a1a1a;
    color: #fff;
    border: 1px solid #333;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
  }

  .control-btn:hover {
    background: #2a2a2a;
  }

  .control-btn:active {
    transform: scale(0.95);
  }

  .control-btn.connected {
    background: #00ff00;
    color: #000;
  }

  .control-btn.sound-factory {
    background: #ff1a78;
    border-color: #ff1a78;
  }

  /* Responsive scaling */
  @media (max-width: 768px) {
    .led-grid {
      width: 100vw;
      height: 100vh;
    }
  }
</style>

<script>
  class LEDDisplay {
    constructor() {
      this.grid = [];
      this.pixels = [];
      this.ws = null;
      this.animationFrame = null;
      this.soundFactoryMode = false;
      this.init();
    }

    init() {
      const ledGrid = document.getElementById('ledGrid');
      const rows = parseInt(ledGrid.dataset.rows);
      const cols = parseInt(ledGrid.dataset.cols);
      
      // Create pixel grid
      for (let row = 0; row < rows; row++) {
        this.grid[row] = [];
        for (let col = 0; col < cols; col++) {
          const pixel = document.createElement('div');
          pixel.className = 'led-pixel';
          pixel.dataset.row = row;
          pixel.dataset.col = col;
          pixel.id = `pixel-${row}-${col}`;
          
          ledGrid.appendChild(pixel);
          this.pixels.push(pixel);
          this.grid[row][col] = pixel;
        }
      }

      // Setup controls
      this.setupControls();
      
      // Setup keyboard shortcuts
      this.setupKeyboard();

      // Initialize WebSocket for live updates
      this.setupWebSocket();
    }

    // Set individual pixel
    setPixel(row, col, color = 'on', brightness = 'bright') {
      const pixel = this.grid[row]?.[col];
      if (pixel) {
        pixel.className = `led-pixel ${color} ${brightness}`;
      }
    }

    // Set multiple pixels at once (batch update)
    setPixels(pixelData) {
      pixelData.forEach(({row, col, color, brightness}) => {
        this.setPixel(row, col, color, brightness);
      });
    }

    // Clear display
    clear() {
      this.pixels.forEach(pixel => {
        pixel.className = 'led-pixel';
      });
    }

    // Fill entire display
    fill(color = 'white', brightness = 'bright') {
      this.pixels.forEach(pixel => {
        pixel.className = `led-pixel ${color} ${brightness}`;
      });
    }

    // Draw rectangle
    drawRect(x, y, width, height, color = 'white') {
      for (let row = y; row < y + height; row++) {
        for (let col = x; col < x + width; col++) {
          this.setPixel(row, col, color);
        }
      }
    }

    // Draw line
    drawLine(x1, y1, x2, y2, color = 'white') {
      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      const sx = x1 < x2 ? 1 : -1;
      const sy = y1 < y2 ? 1 : -1;
      let err = dx - dy;

      while (true) {
        this.setPixel(y1, x1, color);
        
        if (x1 === x2 && y1 === y2) break;
        
        const e2 = 2 * err;
        if (e2 > -dy) {
          err -= dy;
          x1 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y1 += sy;
        }
      }
    }

    // Test pattern
    testPattern() {
      this.clear();
      const rows = this.grid.length;
      const cols = this.grid[0].length;
      
      // Rainbow gradient
      const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink'];
      
      for (let row = 0; row < rows; row++) {
        const colorIndex = Math.floor((row / rows) * colors.length);
        for (let col = 0; col < cols; col++) {
          if ((row + col) % 2 === 0) {
            this.setPixel(row, col, colors[colorIndex]);
          }
        }
      }
    }

    // Sound Factory specific patterns
    soundFactoryMode() {
      this.soundFactoryMode = true;
      this.clear();
      
      // Sound Factory logo pattern
      this.drawRect(40, 80, 20, 40, 'sound-factory-pink');
      this.drawRect(60, 90, 20, 20, 'sound-factory-blue');
      this.drawRect(80, 100, 20, 20, 'sound-factory-gold');
      
      // Animated border
      this.animateBorder();
    }

    // Animate Sound Factory border
    animateBorder() {
      if (!this.soundFactoryMode) return;
      
      const rows = this.grid.length;
      const cols = this.grid[0].length;
      let offset = 0;
      
      const animate = () => {
        if (!this.soundFactoryMode) return;
        
        this.clear();
        
        // Draw animated border
        for (let i = 0; i < cols; i++) {
          const colorIndex = (i + offset) % 3;
          const colors = ['sound-factory-pink', 'sound-factory-blue', 'sound-factory-gold'];
          this.setPixel(0, i, colors[colorIndex]);
          this.setPixel(rows - 1, i, colors[colorIndex]);
        }
        
        for (let i = 0; i < rows; i++) {
          const colorIndex = (i + offset) % 3;
          const colors = ['sound-factory-pink', 'sound-factory-blue', 'sound-factory-gold'];
          this.setPixel(i, 0, colors[colorIndex]);
          this.setPixel(i, cols - 1, colors[colorIndex]);
        }
        
        offset++;
        setTimeout(animate, 100);
      };
      
      animate();
    }

    // Setup WebSocket connection
    setupWebSocket() {
      const wsUrl = this.getWebSocketUrl();
      
      try {
        this.ws = new WebSocket(wsUrl);
        
        this.ws.onopen = () => {
          console.log('WebSocket connected');
          this.updateConnectButton(true);
        };

        this.ws.onmessage = (event) => {
          this.handleWebSocketMessage(event.data);
        };

        this.ws.onclose = () => {
          console.log('WebSocket disconnected');
          this.updateConnectButton(false);
          // Attempt reconnection after 5 seconds
          setTimeout(() => this.setupWebSocket(), 5000);
        };

        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
        };
      } catch (error) {
        console.error('Failed to setup WebSocket:', error);
      }
    }

    getWebSocketUrl() {
      // Use the configured URL or default to current host
      return document.querySelector('[data-ws-url]')?.dataset.wsUrl || 
             `ws://${window.location.hostname}:8080`;
    }

    // Handle incoming WebSocket messages
    handleWebSocketMessage(data) {
      try {
        const message = JSON.parse(data);
        
        switch (message.type) {
          case 'pixel':
            this.setPixel(message.row, message.col, message.color, message.brightness);
            break;
            
          case 'pixels':
            this.setPixels(message.data);
            break;
            
          case 'clear':
            this.clear();
            break;
            
          case 'fill':
            this.fill(message.color, message.brightness);
            break;
            
          case 'rect':
            this.drawRect(message.x, message.y, message.width, message.height, message.color);
            break;
            
          case 'line':
            this.drawLine(message.x1, message.y1, message.x2, message.y2, message.color);
            break;
            
          case 'frame':
            // Handle full frame update
            this.renderFrame(message.data);
            break;
            
          case 'animation':
            // Handle animation sequence
            this.playAnimation(message.frames, message.fps);
            break;
            
          case 'sound-factory':
            this.soundFactoryMode();
            break;
        }
      } catch (error) {
        console.error('Error handling WebSocket message:', error);
      }
    }

    // Render full frame
    renderFrame(frameData) {
      if (Array.isArray(frameData)) {
        frameData.forEach((rowData, row) => {
          rowData.forEach((pixelData, col) => {
            if (pixelData) {
              this.setPixel(row, col, pixelData.color || 'white', pixelData.brightness || 'bright');
            } else {
              this.setPixel(row, col, '', '');
            }
          });
        });
      }
    }

    // Play animation
    playAnimation(frames, fps = 30) {
      let frameIndex = 0;
      const frameDelay = 1000 / fps;
      
      if (this.animationFrame) {
        cancelAnimationFrame(this.animationFrame);
      }
      
      const animate = () => {
        this.renderFrame(frames[frameIndex]);
        frameIndex = (frameIndex + 1) % frames.length;
        
        this.animationFrame = setTimeout(() => {
          requestAnimationFrame(animate);
        }, frameDelay);
      };
      
      animate();
    }

    // Setup control buttons
    setupControls() {
      document.querySelectorAll('.control-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const action = e.target.dataset.action;
          
          switch (action) {
            case 'clear':
              this.clear();
              break;
              
            case 'test':
              this.testPattern();
              break;
              
            case 'connect':
              if (this.ws?.readyState === WebSocket.OPEN) {
                this.ws.close();
              } else {
                this.setupWebSocket();
              }
              break;
              
            case 'sound-factory':
              this.soundFactoryMode();
              break;
          }
        });
      });
    }

    // Setup keyboard shortcuts
    setupKeyboard() {
      document.addEventListener('keydown', (e) => {
        // Toggle control panel with 'C'
        if (e.key === 'c' || e.key === 'C') {
          const panel = document.getElementById('controlPanel');
          panel.classList.toggle('active');
        }
        
        // Clear with 'Space'
        if (e.key === ' ') {
          e.preventDefault();
          this.clear();
        }
        
        // Test pattern with 'T'
        if (e.key === 't' || e.key === 'T') {
          this.testPattern();
        }
        
        // Sound Factory mode with 'S'
        if (e.key === 's' || e.key === 'S') {
          this.soundFactoryMode();
        }
      });
    }

    // Update connect button state
    updateConnectButton(connected) {
      const btn = document.querySelector('[data-action="connect"]');
      if (btn) {
        if (connected) {
          btn.classList.add('connected');
          btn.textContent = 'Connected';
        } else {
          btn.classList.remove('connected');
          btn.textContent = 'Connect Live';
        }
      }
    }

    // Send data to backend
    send(data) {
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify(data));
      }
    }
  }

  // Initialize display
  const display = new LEDDisplay();
  
  // Expose to window for external control
  window.ledDisplay = display;
</script>

